<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>XCel 项目总结 - Electron 与 Vue 的性能优化 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="vue,js-xlsx,electron,data-clening,excel,node,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2016/11/15/xcel/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><meta name="wechat-logo" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/wx_share.jpg"><meta name="wechat-title" content="XCel 项目总结 - Electron 与 Vue 的性能优化"><meta name="wechat-desc" content="本文将分享 Electron、Vue 等相关涉及技术的基本知识和性能优化经验。这也许是Jc的2016年最后一篇文章，且看且不珍惜。"><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="XCEL 是由京东用户体验设计部凹凸实验室推出的一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。 XCEL 基于 Electron 和 Vue 2.x，它不仅跨平台（windows 7+、Mac 和 Linux），而且充分利用 Electron 多进程任务处理等功能，使其性能优异。 落地页：https://xcel.aotu.io/   ✨✨✨项目地址："><meta name="keywords" content="node,excel,data-clening,electron,js-xlsx,vue"><meta property="og:type" content="article"><meta property="og:title" content="XCel 项目总结 - Electron 与 Vue 的性能优化"><meta property="og:url" content="https://aotu.io/notes/2016/11/15/xcel/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="XCEL 是由京东用户体验设计部凹凸实验室推出的一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。 XCEL 基于 Electron 和 Vue 2.x，它不仅跨平台（windows 7+、Mac 和 Linux），而且充分利用 Electron 多进程任务处理等功能，使其性能优异。 落地页：https://xcel.aotu.io/   ✨✨✨项目地址："><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/components.jpg"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/main.jpg"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/renderer.jpg"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/like-this.jpg"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/ipc.jpg"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/app-files.jpg"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/fenge.jpg"><meta property="og:image" content="https://img30.360buyimg.com/ling/jfs/t23491/303/397016798/12152/776e7b40/5b2e3ddbNa8181d28.png"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/install-spinner.gif"><meta property="og:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/multiprocess.jpg"><meta property="og:image" content="https://img20.360buyimg.com/ling/jfs/t22528/169/401386936/20550/9088318e/5b2e3d95N5f402373.png"><meta property="og:image" content="https://img14.360buyimg.com/ling/jfs/t20314/236/1602619966/22609/45b1df6e/5b2e3dabN0676e8d1.png"><meta property="og:image" content="https://img14.360buyimg.com/ling/jfs/t22192/322/1574073289/21531/33f14a3/5b2e3dbaN5a9f3a6d.png"><meta property="og:image" content="https://img10.360buyimg.com/ling/jfs/t21439/62/1600874642/20459/22a0dc08/5b2e3dc5N2a30be1a.png"><meta property="og:image" content="https://img11.360buyimg.com/ling/jfs/t23707/296/382906652/26209/c67155f0/5b2e3dcfN1c2daa62.png"><meta property="og:updated_time" content="2021-02-02T07:48:05.238Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="XCel 项目总结 - Electron 与 Vue 的性能优化"><meta name="twitter:description" content="XCEL 是由京东用户体验设计部凹凸实验室推出的一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。 XCEL 基于 Electron 和 Vue 2.x，它不仅跨平台（windows 7+、Mac 和 Linux），而且充分利用 Electron 多进程任务处理等功能，使其性能优异。 落地页：https://xcel.aotu.io/   ✨✨✨项目地址："><meta name="twitter:image" content="https://misc.aotu.io/JChehe/2016-11-15-xcel/components.jpg"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script><script>window.WechatShareData={imgUrl:"https://misc.aotu.io/JChehe/2016-11-15-xcel/wx_share.jpg",link:window.location.href,title:"XCel 项目总结 - Electron 与 Vue 的性能优化",desc:"本文将分享 Electron、Vue 等相关涉及技术的基本知识和性能优化经验。这也许是Jc的2016年最后一篇文章，且看且不珍惜。"},window.WechatJSSDKURL="https://aotu.jd.com/aotu-wx-api/api/wx/jssdk/signature"</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/poster.jpg" alt="XCel 项目总结 - Electron 与 Vue 的性能优化"></div><header class="post-hd"><h1 class="post-tit">XCel 项目总结 - Electron 与 Vue 的性能优化</h1><div class="post-meta">by <a target="_blank" href="https://github.com/JChehe" class="post-author">Jc</a> on <span>2016-11-15</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>XCel 是一款基于用研组需求的 Excel 数据过滤工具，本文将分享 Electron、Vue 等相关涉及技术的基本知识和性能优化经验。这也许是Jc的2016年最后一篇文章，且看且不珍惜。</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><p>XCEL 是由京东用户体验设计部凹凸实验室推出的一个 Excel 数据清洗工具，其通过可视化的方式让用户轻松地对 Excel 数据进行筛选。</p><p>XCEL 基于 Electron 和 Vue 2.x，它不仅跨平台（windows 7+、Mac 和 Linux），而且充分利用 Electron 多进程任务处理等功能，使其性能优异。</p><p>落地页：<a href="https://xcel.aotu.io/" target="_blank" rel="noopener">https://xcel.aotu.io/</a> ✨✨✨<br>项目地址：<a href="https://github.com/o2team/xcel" target="_blank" rel="noopener">https://github.com/o2team/xcel</a> ✨✨✨</p><h2 id="项目背景" class="post-heading"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景<a class="post-anchor" href="#项目背景" aria-hidden="true"></a></h2><p>用户研究的定量研究和轻量级数据处理中，均需对数据进行清洗处理，以剔除异常数据，保证数据结果的信度和效度。目前因调研数据和轻量级数据的多变性，对轻量级数据清洗往往采取人工清洗，缺少统一、标准的清洗流程，但对于调研和轻量级的数据往往是需要保证数据稳定性的，因此，在对数据进行清洗时最好有标准化的清洗方式。</p><h2 id="特性一览" class="post-heading"><a href="#特性一览" class="headerlink" title="特性一览"></a>特性一览<a class="post-anchor" href="#特性一览" aria-hidden="true"></a></h2><ul><li>基于 Electron 研发并打包成为原生应用，用户体验良好；</li><li>可视化操作 Excel 数据，支持文件的导入导出；</li><li>拥有单列运算逻辑、多列运算逻辑和双列范围逻辑三种筛选方式，并且可通过“且”、“或”和“编组”的方式任意组合。</li></ul><h2 id="思路与实现" class="post-heading"><a href="#思路与实现" class="headerlink" title="思路与实现"></a>思路与实现<a class="post-anchor" href="#思路与实现" aria-hidden="true"></a></h2><p>基于用研组的需求，利用 Electron 和 Vue 的特性对该工具进行开发。</p><h3 id="技术选型" class="post-heading"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型<a class="post-anchor" href="#技术选型" aria-hidden="true"></a></h3><ul><li>Electron：桌面端跨平台框架，为 Web 提供了原生接口的权限。打包后的程序兼容 Windows 7 及以上、Mac、Linux 的 32 / 64 位系统。<a href="http://electron.atom.io/" target="_blank" rel="noopener">详情&gt;&gt;</a></li><li>Vue 全家桶：Vue 拥有数据驱动视图的特性，适合重数据交互的应用。<a href="http://vuejs.org/" target="_blank" rel="noopener">详情&gt;&gt;</a></li><li>js-xlsx：兼容各种电子表格格式的解析器和生成器。纯 JavaScript 实现，适用于 Node.js 和 Web 前端。<a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">详情&gt;&gt;</a></li></ul><h3 id="实现思路" class="post-heading"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路<a class="post-anchor" href="#实现思路" aria-hidden="true"></a></h3><ol><li>通过 js-xlsx 将 Excel 文件解析为 JSON 数据</li><li>根据筛选条件对 JSON 数据进行筛选过滤</li><li>将过滤后的 JSON 数据转换成 js-xlsx 指定的数据结构</li><li>利用 js-xlsx 对转换后的数据生成 Excel 文件</li></ol><hr><p><strong>纸上得来终觉浅，绝知此事要躬行</strong></p><h2 id="相关技术" class="post-heading"><a href="#相关技术" class="headerlink" title="相关技术"></a>相关技术<a class="post-anchor" href="#相关技术" aria-hidden="true"></a></h2><p>如果对某项技术比较熟悉，则可略读/跳过。</p><h3 id="Electron" class="post-heading"><a href="#Electron" class="headerlink" title="Electron"></a>Electron<a class="post-anchor" href="#Electron" aria-hidden="true"></a></h3><h4 id="Electron-是什么？" class="post-heading"><a href="#Electron-是什么？" class="headerlink" title="Electron 是什么？"></a>Electron 是什么？<a class="post-anchor" href="#Electron-是什么？" aria-hidden="true"></a></h4><p>Electron 是一个可以用 <strong>JavaScript、HTML 和 CSS</strong> 构建桌面应用程序的<strong>库</strong>。这些应用程序能打包到 Mac、Windows 和 Linux 系统上运行，也能上架到 Mac 和 Windows 的 App Store。</p><ul><li><strong>JavaScript、HTML 和 CSS</strong> 都是 Web 语言，它们是组成网站的一部分，浏览器（如 Chrome）懂得如何将这些代码转为可视化图像。</li><li><strong>Electron 是一个库</strong>：Electron 对底层代码进行抽象和封装，让开发者能在此之上构建项目。</li></ul><h4 id="为什么它如此重要？" class="post-heading"><a href="#为什么它如此重要？" class="headerlink" title="为什么它如此重要？"></a>为什么它如此重要？<a class="post-anchor" href="#为什么它如此重要？" aria-hidden="true"></a></h4><p>通常来说，每个操作系统的桌面应用都由各自的原生语言进行编写，这意味着需要 3 个团队分别为该应用编写相应版本。而 Electron 则允许你用 Web 语言编写一次即可。</p><ul><li><strong>原生（操作系统）语言</strong>：用于开发主流操作系统应用的原生语言的对应关系（大多数情况下）：Mac 对应 Objective C、Linux 对应 C、Windows 对应 C++。</li></ul><h4 id="它由什么组成？" class="post-heading"><a href="#它由什么组成？" class="headerlink" title="它由什么组成？"></a>它由什么组成？<a class="post-anchor" href="#它由什么组成？" aria-hidden="true"></a></h4><p>Electron 结合了 <strong>Chromium</strong>、<strong>Node.js</strong> 和用于调用操作系统本地功能的 API（如打开文件窗口、通知、图标等）。</p><ul><li><strong>Chromium</strong>：Google 创造的一个开源库，并用于 Google 的浏览器 Chrome。</li><li><strong>Node.js（Node）</strong>：一个在服务器运行 JavaScript 的运行时（runtime），它拥有访问文件系统和网络权限（你的电脑也可以是一台服务器！）。</li></ul><p><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/components.jpg" alt="Electron 的组成"></p><h4 id="开发体验如何？" class="post-heading"><a href="#开发体验如何？" class="headerlink" title="开发体验如何？"></a>开发体验如何？<a class="post-anchor" href="#开发体验如何？" aria-hidden="true"></a></h4><p>基于 Electron 的开发就像在开发网页，而且能够无缝地 <strong>使用 Node</strong>。或者说：在构建一个 Node 应用的同时，通过 HTML 和 CSS 构建界面。另外，你只需为一个浏览器（<strong>最新的 Chrome</strong>）进行设计（即无需考虑兼容性等）。</p><ul><li><strong>使用 Node</strong>：这还不是全部！除了完整的 Node API，你还可以使用托管在 npm 上超过 350,000 个的模块。</li><li><strong>一个浏览器</strong>：并非所有浏览器都提供一致的样式，Web 设计师和开发者经常因此而不得不花费更多的精力，让网站在不同浏览器上表现一致。</li><li><strong>最新的 Chrome</strong>：可使用超过 90% 的 ES2015 特性和其它很酷的特性（如 CSS 变量）。</li></ul><h4 id="两个进程（重点）" class="post-heading"><a href="#两个进程（重点）" class="headerlink" title="两个进程（重点）"></a>两个进程（重点）<a class="post-anchor" href="#两个进程（重点）" aria-hidden="true"></a></h4><p>Electron 有两种进程：『主进程』和『渲染进程』。部分模块只能在两者之一上运行，而有些则无限制。主进程更多地充当幕后角色，而渲染进程则是应用程序的各个窗口。</p><blockquote><p>注：可通过任务管理器（PC）/活动监视器（Mac）查看进程的相关信息。</p></blockquote><ul><li><strong>模块</strong>：Electron 的 API 是根据它们的用途进行分组。例如：<code>dialog</code> 模块拥有所有原生 dialog 的 API，如打开文件、保存文件和警告等弹窗。</li></ul><h4 id="主进程" class="post-heading"><a href="#主进程" class="headerlink" title="主进程"></a>主进程<a class="post-anchor" href="#主进程" aria-hidden="true"></a></h4><p>主进程，通常是一个命名为 <code>main.js</code> 的文件，该文件是每个 Electron 应用的入口。它控制了应用的生命周期（从打开到关闭）。它既能<strong>调用原生元素</strong>，也能创建新的（多个）渲染进程。另外，Node API 是内置其中的。</p><ul><li><strong>调用原生元素</strong>：打开 diglog 和其它操作系统的交互均是资源密集型操作（注：出于安全考虑，渲染进程是不能直接访问本地资源的），因此都需要在主进程完成。</li></ul><p><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/main.jpg" alt="主进程"></p><h4 id="渲染进程" class="post-heading"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程<a class="post-anchor" href="#渲染进程" aria-hidden="true"></a></h4><p>渲染进程是应用的一个浏览器窗口。与主进程不同，它能存在多个（注：一个 Electron 应用只能存在一个主进程）并且<strong>相互独立</strong>（它也能是<strong>隐藏的</strong>）。主窗口通常被命名为 <code>index.html</code>。它们就像典型的 HTML 文件，但 Electron 赋予了它们完整的 Node API。因此，这也是它与浏览器的区别。</p><ul><li><strong>相互独立</strong>：每个渲染进程都是独立的，这意味着某个渲染进程的崩溃，也不会影响其余渲染进程。</li><li><strong>隐藏</strong>：可隐藏窗口，然后让其在背后运行代码（👍）。</li></ul><p><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/renderer.jpg" alt="渲染进程"></p><h4 id="把它们想象成这样" class="post-heading"><a href="#把它们想象成这样" class="headerlink" title="把它们想象成这样"></a>把它们想象成这样<a class="post-anchor" href="#把它们想象成这样" aria-hidden="true"></a></h4><p>Chrome（或其他浏览器）的每个标签页（tab）及其页面，就好比 Electron 中的一个单独渲染进程。即使关闭所有标签页，Chrome 依然存在。这好比 Electron 的主进程，能打开新的窗口或关闭这个应用。</p><blockquote><p>注：在 Chrome 浏览器中，一个标签页（tab）中的页面（即除了浏览器本身部分，如搜索框、工具栏等）就是一个渲染进程。</p></blockquote><p><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/like-this.jpg" alt="把它们想象成这样"></p><h4 id="相互通讯" class="post-heading"><a href="#相互通讯" class="headerlink" title="相互通讯"></a>相互通讯<a class="post-anchor" href="#相互通讯" aria-hidden="true"></a></h4><p>由于主进程和渲染进程各自负责不同的任务，而对于需要协同完成的任务，它们需要相互通讯。<strong>IPC</strong>就为此而生，它提供了进程间的通讯。但它只能在主进程与渲染进程之间传递信息（即渲染进程之间不能进行直接通讯）。</p><ul><li><strong>IPC</strong>：主进程和渲染进程各自拥有一个 IPC 模块。</li></ul><p><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/ipc.jpg" alt="IPC Main 与 IPC Renderer"></p><h4 id="汇成一句话" class="post-heading"><a href="#汇成一句话" class="headerlink" title="汇成一句话"></a>汇成一句话<a class="post-anchor" href="#汇成一句话" aria-hidden="true"></a></h4><p>Electron 应用就像 Node 应用，它也依赖一个 <code>package.json</code> 文件。该文件定义了哪个文件作为主进程，并因此让 Electron 知道从何启动应用。然后主进程能创建渲染进程，并能使用 IPC 让两者间进行消息传递。</p><p><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/app-files.jpg" alt="汇成一句话"></p><p>至此，Electron 的基础部分介绍完毕。该部分是基于笔者之前翻译的一篇文章<a href="http://jlord.us/essential-electron/" target="_blank" rel="noopener">《Essential Electron》</a>，译文可点击 <a href="https://segmentfault.com/a/1190000007503495" target="_blank" rel="noopener">这里</a>。</p><hr><h3 id="Vue-全家桶" class="post-heading"><a href="#Vue-全家桶" class="headerlink" title="Vue 全家桶"></a>Vue 全家桶<a class="post-anchor" href="#Vue-全家桶" aria-hidden="true"></a></h3><p>该工具使用了 Vue、Vuex、Vuex-router。在工具基本定型阶段，由 1.x 升级到了 2.x。</p><h4 id="为什么选择-Vue" class="post-heading"><a href="#为什么选择-Vue" class="headerlink" title="为什么选择 Vue"></a>为什么选择 Vue<a class="post-anchor" href="#为什么选择-Vue" aria-hidden="true"></a></h4><p>对于笔者来说：</p><ul><li>简单易用，一般使用只需看官方文档。</li><li>数据驱动视图，所以基本不用操作 DOM 了。</li><li>框架的存在是为了帮助我们应对复杂度。</li><li>全家桶的好处是：对于一般场景，我们就不需要考虑用哪些个库（插件）。</li></ul><p>Vue 1.x -&gt; Vue 2.0 的版本迁移用 <a href="https://github.com/vuejs/vue-migration-helper" target="_blank" rel="noopener">vue-migration-helper</a> 即可分析出大部分需要更改的地方。</p><p>网上已有很多关于 Vue 的教程，故在此不再赘述。至此，Vue 部分介绍完毕。</p><hr><h3 id="js-xlsx" class="post-heading"><a href="#js-xlsx" class="headerlink" title="js-xlsx"></a>js-xlsx<a class="post-anchor" href="#js-xlsx" aria-hidden="true"></a></h3><p>该库支持各种电子表格格式的解析与生成。它由 JavaScript 实现，适用于前端和 Node。<a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">详情&gt;&gt;</a></p><p>目前支持读入的格式有（不断更新）：</p><ul><li>Excel 2007+ XML Formats (XLSX/XLSM)</li><li>Excel 2007+ Binary Format (XLSB)</li><li>Excel 2003-2004 XML Format (XML “SpreadsheetML”)</li><li>Excel 97-2004 (XLS BIFF8)</li><li>Excel 5.0/95 (XLS BIFF5)</li><li>OpenDocument Spreadsheet (ODS)</li></ul><p>支持写出的格式有：</p><ul><li>XLSX</li><li>CSV (and general DSV)</li><li>JSON and JS objects (various styles)</li></ul><p>目前该库提供的 <code>sheet_to_json</code> 方法能将读入的 Excel 数据转为 JSON 格式。而对于导出操作，我们需要为 js-xlsx 提供指定的 JSON 格式。</p><p>更多关于 Excel 在 JavaScript 中处理的知识可查看凹凸实验室的<a href="https://aotu.io/notes/2016/04/07/node-excel/">《Node读写Excel文件探究实践》</a>。但该文章存在两处问题（均在 js-xlsx 实战的导出表格部分）：</p><ol><li>生成头部时，Excel 的列信息简单地通过 <code>String.fromCharCode(65+j)</code> 生成。当列大于 26 时会出现问题。这个问题会在后面章节中给出解决方案；</li><li>转换成 worksheet 需要的结构处，出现逻辑性错误，并且会导致严重的性能问题。逻辑问题在此不讲述，我们看看性能问题：<br>随着 ECMAScript 的不断更新，JavaScript 变得更加强大和易用。尽管如此，我们还是要做到『物尽所用』，而不要『大材小用』，否则可能会得到“反效果”。这里导致性能问题的正是 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign" target="_blank" rel="noopener">Object.assign()</a> 方法，该方法可以把任意多个源对象的可枚举属性拷贝至目标对象，并返回目标对象。由于该方法自身的实现机制，会在此案例中产生大量的冗余操作。在该案例中，单元格信息是唯一的，所以直接通过 forEach 为一个空对象赋值即可。提升 N 倍性能的同时，也把逻辑性错误解决了。</li></ol><p>原来的：<br></p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result = 某数组.reduce(<span class="function"><span class="params">(prev, <span class="built_in">next</span>)</span> =&gt;</span> Object.assign(&#123;&#125;, prev, &#123;[<span class="built_in">next</span>.position]: &#123;<span class="name">v</span>: <span class="built_in">next</span>.v&#125;&#125;), &#123;&#125;);</span><br></pre></td></tr></table></figure><p></p><p>改为：<br></p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = 某数组.forEach(<span class="function">(<span class="params">v, i</span>) =&gt;</span> data[v.position]= &#123;<span class="attr">v</span>: v.v&#125;)</span><br></pre></td></tr></table></figure><p></p><hr><p><strong>实践是检验真理的唯一标准</strong></p><p>在理解上述知识后，下面就谈谈在该项目实践中总结出来的<strong>技巧、难点和重点</strong>。</p><h2 id="CSS、JavaScript-和-Electron-相关的知识和技巧" class="post-heading"><a href="#CSS、JavaScript-和-Electron-相关的知识和技巧" class="headerlink" title="CSS、JavaScript 和 Electron 相关的知识和技巧"></a>CSS、JavaScript 和 Electron 相关的知识和技巧<a class="post-anchor" href="#CSS、JavaScript-和-Electron-相关的知识和技巧" aria-hidden="true"></a></h2><h3 id="高亮-table-的列" class="post-heading"><a href="#高亮-table-的列" class="headerlink" title="高亮 table 的列"></a>高亮 table 的列<a class="post-anchor" href="#高亮-table-的列" aria-hidden="true"></a></h3><p>Excel 单元格采用 <code>table</code> 标签展示。在 Excel 中，被选中的单元格会高亮相应的『行』和『列』，以提醒用户。在该应用中也有做相应的处理，横向高亮采用 <code>tr:hover</code> 实现，而纵向呢？这里所采用的一个技巧是：</p><p>假设 HTML 结构如下：<br></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>.container</span><br><span class="line">  table</span><br><span class="line">    tr</span><br><span class="line">      td</span><br></pre></td></tr></table></figure><p></p><p>CSS 代码如下：<br></p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123; <span class="attribute">overflow</span>:hidden; &#125;</span><br><span class="line"><span class="selector-tag">td</span> &#123; <span class="attribute">position</span>: relative; &#125;</span><br><span class="line"><span class="selector-tag">td</span>:hover::after &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>; </span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">1</span>个亿px; <span class="comment">// 小目标达成，不过是负的😭</span></span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">1</span>个亿px; </span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>; <span class="comment">// 避免遮住自身和同列 td 的内容、border 等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="斜分割线" class="post-heading"><a href="#斜分割线" class="headerlink" title="斜分割线"></a>斜分割线<a class="post-anchor" href="#斜分割线" aria-hidden="true"></a></h3><p>如图：<img src="//misc.aotu.io/JChehe/2016-11-15-xcel/fenge.jpg" alt="斜分割线"></p><p>分割线可以通过 <code>::after/::before</code> 伪类元素实现一条直线，然后通过 <code>transform:rotate();</code> 旋转特定角度实现。但这种实现的一个问题是：由于宽度是不定的，因此需要通过 JavaScript 运算才能得到准确的对角分割线。</p><p>因此，这里可以通过 CSS 线性渐变 <code>linear-gradient(to top right, transparent, transparent calc(50% - .5px), #d3d6db calc(50% - .5px), #d3d6db calc(50% + .5px), transparent calc(50% + .5px))</code> 实现。无论宽高如何变，依然妥妥地自适应。</p><h3 id="Excel-的列转换" class="post-heading"><a href="#Excel-的列转换" class="headerlink" title="Excel 的列转换"></a>Excel 的列转换<a class="post-anchor" href="#Excel-的列转换" aria-hidden="true"></a></h3><ul><li>Excel 的列需要用『字母』表示，但不能简单地通过 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCharCode" target="_blank" rel="noopener">String.fromCharCode()</a> 实现，因为当超出 <code>26 列</code> 时就会产生问题（如：第 <code>27</code> 列，<code>String.fromCharCode(65+26)</code> 得到的是 <code>[</code>，而不是 <code>AA</code>）。因此，这需要通过『十进制和 26 进制转换』算法来实现。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将传入的自然数转换为26进制表示。映射关系：[0-25] -&gt; [A-Z]。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCharCol</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="string">''</span></span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    m = (n % <span class="number">26</span>) + <span class="number">1</span></span><br><span class="line">    s = <span class="built_in">String</span>.fromCharCode(m + <span class="number">64</span>) + s</span><br><span class="line">    n = (n - m) / <span class="number">26</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将传入的26进制转换为自然数。映射关系：[A-Z] -&gt;[0-25]。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumCol</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = s.length - <span class="number">1</span>, j = <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--, j *= <span class="number">26</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> c = s[i].toUpperCase()</span><br><span class="line">    <span class="keyword">if</span> (c &lt; <span class="string">'A'</span> || c &gt; <span class="string">'Z'</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    n += (c.charCodeAt() - <span class="number">64</span>) * j</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为-DOM-的-File-对象增加了-path-属性" class="post-heading"><a href="#为-DOM-的-File-对象增加了-path-属性" class="headerlink" title="为 DOM 的 File 对象增加了 path 属性"></a>为 DOM 的 File 对象增加了 path 属性<a class="post-anchor" href="#为-DOM-的-File-对象增加了-path-属性" aria-hidden="true"></a></h3><p>Electron 为 File 对象额外增了 path 属性，该属性可得到文件在文件系统上的真实路径。因此，你可以利用 Node 为所欲为😈。应用场景有：拖拽文件后，通过 Node 提供的 File API 读取文件等。</p><h3 id="支持常见的编辑功能，如粘贴和复制" class="post-heading"><a href="#支持常见的编辑功能，如粘贴和复制" class="headerlink" title="支持常见的编辑功能，如粘贴和复制"></a>支持常见的编辑功能，如粘贴和复制<a class="post-anchor" href="#支持常见的编辑功能，如粘贴和复制" aria-hidden="true"></a></h3><p>Electron 应用在 MacOS 中默认不支持『复制』『粘贴』等常见编辑功能，因此需要为 MacOS 显式地设置复制粘贴等编辑功能的菜单栏，并为此设置相应的快捷键。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// darwin 就是 MacOS</span><br><span class="line">if (process.platform === <span class="string">'darwin'</span>) &#123;</span><br><span class="line">    var template = [&#123;</span><br><span class="line">      <span class="keyword">label</span><span class="bash">: <span class="string">'FromScratch'</span>,</span></span><br><span class="line">      submenu: [&#123;</span><br><span class="line">        <span class="keyword">label</span><span class="bash">: <span class="string">'Quit'</span>,</span></span><br><span class="line">        accelerator: <span class="string">'CmdOrCtrl+Q'</span>,</span><br><span class="line">        click: function() &#123; app.quit(); &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      <span class="keyword">label</span><span class="bash">: <span class="string">'Edit'</span>,</span></span><br><span class="line">      submenu: [&#123;</span><br><span class="line">        <span class="keyword">label</span><span class="bash">: <span class="string">'Undo'</span>,</span></span><br><span class="line">        accelerator: <span class="string">'CmdOrCtrl+Z'</span>,</span><br><span class="line">        selector: <span class="string">'undo:'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="keyword">label</span><span class="bash">: <span class="string">'Redo'</span>,</span></span><br><span class="line">        accelerator: <span class="string">'Shift+CmdOrCtrl+Z'</span>,</span><br><span class="line">        selector: <span class="string">'redo:'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        type: <span class="string">'separator'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="keyword">label</span><span class="bash">: <span class="string">'Cut'</span>,</span></span><br><span class="line">        accelerator: <span class="string">'CmdOrCtrl+X'</span>,</span><br><span class="line">        selector: <span class="string">'cut:'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="keyword">label</span><span class="bash">: <span class="string">'Copy'</span>,</span></span><br><span class="line">        accelerator: <span class="string">'CmdOrCtrl+C'</span>,</span><br><span class="line">        selector: <span class="string">'copy:'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="keyword">label</span><span class="bash">: <span class="string">'Paste'</span>,</span></span><br><span class="line">        accelerator: <span class="string">'CmdOrCtrl+V'</span>,</span><br><span class="line">        selector: <span class="string">'paste:'</span></span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        <span class="keyword">label</span><span class="bash">: <span class="string">'Select All'</span>,</span></span><br><span class="line">        accelerator: <span class="string">'CmdOrCtrl+A'</span>,</span><br><span class="line">        selector: <span class="string">'selectAll:'</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;];</span><br><span class="line">    var osxMenu = menu.buildFromTemplate(template);</span><br><span class="line">    menu.setApplicationMenu(osxMenu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更贴近原生应用" class="post-heading"><a href="#更贴近原生应用" class="headerlink" title="更贴近原生应用"></a>更贴近原生应用<a class="post-anchor" href="#更贴近原生应用" aria-hidden="true"></a></h3><p>Electron 的一个缺点是：即使你的应用是一个简单的时钟，但它也不得不包含完整的基础设施（如 Chromium、Node 等）。因此，一般情况下，打包后的程序至少会达到几十兆（根据系统类型进行浮动）。当你的应用越复杂，就越可以忽略文件体积问题。</p><p>众所周知，页面的渲染难免会导致『白屏』，而且这里采用了 Vue 这类框架，情况就更加糟糕了。另外，Electron 应用也避免不了『先打开浏览器，再渲染页面』的步骤。下面提供几种方法来减轻这种情况，以让程序更贴近原生应用。</p><ol><li>指定 BrowserWindow 的背景颜色；</li><li>先隐藏窗口，直到页面加载后再显示；</li><li>保存窗口的尺寸和位置，以让程序下次被打开时，依然保留的同样大小和出现在同样的位置上。</li></ol><p>对于第一点，若应用的背景不是纯白（<code>#fff</code>）的，那么可指定窗口的背景颜色与其一致，以避免渲染后的突变。<br></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">mainWindow</span> = new BrowserWindow(&#123;</span><br><span class="line">    title: <span class="string">'XCel'</span>,</span><br><span class="line">    backgroundColor: <span class="string">'#f5f5f5'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>对于第二点，由于 Electron 本质是一个浏览器，需要加载非网页部分的资源。因此，我们可以先隐藏窗口。<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">    title: <span class="string">'ElectronApp'</span>,</span><br><span class="line">    <span class="keyword">show</span>: <span class="keyword">false</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>等到渲染进程开始渲染页面的那一刻，在 <code>ready-to-show</code> 的回调函数中显示窗口。<br></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mainWindow.<span class="keyword">on</span><span class="params">('ready-to-show', function<span class="params">()</span> &#123;</span></span><br><span class="line"><span class="params">    mainWindow.show<span class="params">()</span>;</span></span><br><span class="line"><span class="params">    mainWindow.focus<span class="params">()</span>;</span></span><br><span class="line"><span class="params">&#125;)</span>;</span><br></pre></td></tr></table></figure><p></p><p>对于第三点，笔者并没有实现，原因如下：</p><ol><li>用户一般是根据当时的情况对程序的尺寸和位置进行调整，即视情况而定。</li><li>以上是我个人臆测，主要是我懒🐶。</li></ol><p>其实现方式，可参考<a href="https://blog.avocode.com/blog/4-must-know-tips-for-building-cross-platform-electron-apps" target="_blank" rel="noopener">《4 must-know tips for building cross platform Electron apps》</a>。</p><h3 id="如何在渲染进程调用原生弹框？" class="post-heading"><a href="#如何在渲染进程调用原生弹框？" class="headerlink" title="如何在渲染进程调用原生弹框？"></a>如何在渲染进程调用原生弹框？<a class="post-anchor" href="#如何在渲染进程调用原生弹框？" aria-hidden="true"></a></h3><p>在渲染进程中调用原本专属于主进程中的 API （如弹框）的方式有两种：</p><ol><li>IPC 通讯模块：先在主进程通过 <code>ipcMain</code> 进行监听，然后在渲染进程通过 <code>ipcRenderer</code> 进行触发；</li><li>remote 模块：该模块为渲染进程和主进程之间提供了快捷的通讯方式。</li></ol><p>对于第二种方式，在渲染进程中，运行以下代码即可：<br></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> remote = <span class="built_in">require</span>(<span class="string">'electron'</span>).remote</span><br><span class="line"></span><br><span class="line">remote.dialog.showMessageBox(&#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'question'</span>,</span><br><span class="line">  buttons: [<span class="string">'不告诉你'</span>, <span class="string">'没有梦想'</span>],</span><br><span class="line">  defaultId: <span class="number">0</span>,</span><br><span class="line">  title: <span class="string">'XCel'</span>,</span><br><span class="line">  message: <span class="string">'你的梦想是什么？'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="自动更新" class="post-heading"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新<a class="post-anchor" href="#自动更新" aria-hidden="true"></a></h3><p>如果 Electron 应用没有提供自动更新功能，那么就意味着用户想体验新开发的功能或用上修复 Bug 后的新版本，只能靠用户自己主动地去官网下载，这无疑是糟糕的体验。Electron 提供的 <a href="http://electron.atom.io/docs/api/auto-updater/" target="_blank" rel="noopener">autoUpdater</a> 模块可实现自动更新功能，该模块提供了第三方框架 <a href="https://github.com/Squirrel" target="_blank" rel="noopener">Squirrel</a> 的接口，但 Electron 目前只内置了 <a href="https://github.com/Squirrel/Squirrel.Mac" target="_blank" rel="noopener">Squirrel.Mac</a>，且它与 <a href="https://github.com/Squirrel/Squirrel.Windows" target="_blank" rel="noopener">Squirrel.Windows</a>（需要额外引入）的处理方式也不一致（在客户端与服务器端两方面）。因此如果对该模块不熟悉，处理起来会相对比较繁琐。具体可以参考笔者的另一篇译文<a href="https://segmentfault.com/a/1190000007616641" target="_blank" rel="noopener">《Electron 自动更新的完整教程（Windows 和 OSX）》</a>。</p><blockquote><p>目前 Electron 的 autoUpdater 模块不支持 Linux 系统。</p></blockquote><p>另外，XCel 目前并没有采用 autoUpdater 模块实现自动更新功能，而是利用 Electron 的 <a href="http://electron.atom.io/docs/api/download-item/" target="_blank" rel="noopener">DownloadItem</a> 模块实现，而服务器端则采用了 <a href="https://nuts.gitbook.com/" target="_blank" rel="noopener">Nuts</a>。</p><h3 id="为-Electron-应用生成-Windows-安装包" class="post-heading"><a href="#为-Electron-应用生成-Windows-安装包" class="headerlink" title="为 Electron 应用生成 Windows 安装包"></a>为 Electron 应用生成 Windows 安装包<a class="post-anchor" href="#为-Electron-应用生成-Windows-安装包" aria-hidden="true"></a></h3><p>通过 <a href="https://www.electron.build/" target="_blank" rel="noopener">electron-builder</a> 可直接生成常见的 MacOS 安装包，但它生成的 Windows 的安装包却略显简洁（默认选项时）。</p><p><img src="https://img30.360buyimg.com/ling/jfs/t23491/303/397016798/12152/776e7b40/5b2e3ddbNa8181d28.png" alt="常见的MacOS 安装包"><br>Mac 常见的安装模式，将“左侧的应用图标”拖拽到“右侧的 Applications”即可</p><p>通过 electron-builder 生成的 Windows 安装包与我们在 Windows 上常见的软件安装界面不太一样，它没有安装向导和点击“下一步”的按钮，只有一个安装时的 gif 动画（默认的 gif 动画如下图，当然你也可以指定特定的 gif 动画），因此也就关闭了用户选择安装路径等权利。</p><p><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/install-spinner.gif" alt="Windows 安装时默认的动画"><br>Windows 安装时 <a href="https://github.com/electron/windows-installer/blob/master/resources/install-spinner.gif" target="_blank" rel="noopener">默认显示的 gif 动画</a></p><p>如果你想为打包后的 Electron 应用（即通过 electron-packager/electron-builder 生成的，可直接运行的程序目录）生成拥有点击“下一步”按钮和可让用户指定安装路径的常见安装包，可以尝试 NSIS 程序，具体可看这篇教程 <a href="http://seesawworld.blogspot.com/2016/02/1-nsis.html" target="_blank" rel="noopener">《[教學]只要10分鐘學會使用 NSIS 包裝您的桌面軟體–安裝程式打包。完全免費。》</a>。</p><p>注：electron-builder 也提供了生成安装包的配置项，<a href="https://www.electron.build/configuration/nsis" target="_blank" rel="noopener">具体查看&gt;&gt;</a>。</p><blockquote><p>NSIS（Nullsoft Scriptable Install System）是一个开源的 Windows 系统下安装程序制作程序。它提供了安装、卸载、系统设置、文件解压缩等功能。正如其名字所描述的那样，NSIS 是通过它的脚本语言来描述安装程序的行为和逻辑的。NSIS 的脚本语言和常见的编程语言有类似的结构和语法，但它是为安装程序这类应用所设计的。</p></blockquote><p>至此，CSS、JavaScript 和 Electron 相关的知识和技巧部分阐述完毕。</p><hr><h2 id="性能优化" class="post-heading"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化<a class="post-anchor" href="#性能优化" aria-hidden="true"></a></h2><p>下面谈谈『性能优化』，这部分涉及到<strong>运行效率</strong>和<strong>内存占用量</strong>。<br>注：以下内容均基于 Excel 样例文件（数据量为：1913 行 x 180 列）得出的结论。</p><h3 id="执行效率和渲染的优化" class="post-heading"><a href="#执行效率和渲染的优化" class="headerlink" title="执行效率和渲染的优化"></a>执行效率和渲染的优化<a class="post-anchor" href="#执行效率和渲染的优化" aria-hidden="true"></a></h3><h4 id="Vue-性能真的好？" class="post-heading"><a href="#Vue-性能真的好？" class="headerlink" title="Vue 性能真的好？"></a>Vue 性能真的好？<a class="post-anchor" href="#Vue-性能真的好？" aria-hidden="true"></a></h4><p>Vue 一直标榜着自己性能优异，但当数据量上升到一定量级时（如 1913 x 180 ≈ 34 万个数据单元），会出现严重的性能问题（未做相应优化的前提下）。</p><p>如直接通过列表渲染 <code>v-for</code> 渲染数据时，会导致程序卡死。<br>答：通过查阅相关资料可得， <code>v-for</code> 在初次渲染时，需要对每个子项进行初始化（如数据绑定等操作，以便拥有更快的更新速度），这对于数据量较大时，无疑会造成严重的性能问题。</p><p>当时，我想到了两种解决思路：</p><ol><li>Vue 是数据驱动视图的，对数据分段 push，即将一个庞大的任务分割为 N 份。</li><li>自己拼接 HTML 字符串，再通过 innerHTML 一次性插入。</li></ol><p>最终，我选择了第二条，理由是：</p><ol><li>性能最佳，因为每次执行数据过滤时，Vue 都要进行 diff，性能不佳。</li><li>更符合当前应用的需求：纯展示且无需动画过渡等。</li><li>实现更简单</li></ol><p>将原本繁重的 DOM 操作（Vue）转换为 JavaScript 的拼接字符串后，性能得到了很大提升（不会导致程序卡死而渲染不出视图）。这种优化方式难道不就是 Vue、React 等框架解决的问题之一吗？只不过框架考虑的场景更广，有些地方需要我们自己根据实际情况进行优化而已。</p><blockquote><p>在浏览器当中，JavaScript 的运算在现代的引擎中非常快，但 DOM 本身是非常缓慢的东西。当你调用原生 DOM API 的时候，浏览器需要在 JavaScript 引擎的语境下去接触原生的 DOM 的实现，这个过程有相当的性能损耗。所以，本质的考量是，要把耗费时间的操作尽量放在纯粹的计算中去做，保证最后计算出来的需要实际接触真实 DOM 的操作是最少的。 —— <a href="http://www.infoq.com/cn/articles/vue-2-progressive-front-end-solution" target="_blank" rel="noopener">《Vue 2.0——渐进式前端解决方案》</a></p></blockquote><p>当然，由于 JavaScript 天生单线程，即使执行数速度再快，也难免会导致页面有短暂的时间拒绝用户的输入。此时可通过 Web Worker 或其它方式解决，这也将是我们后续讲到的问题。</p><p>也有网友提供了优化大量列表的方法：<a href="https://clusterize.js.org/" target="_blank" rel="noopener">https://clusterize.js.org/</a>。但在此案例中笔者并没有采用此方式。</p><h4 id="强大的-GPU-加速" class="post-heading"><a href="#强大的-GPU-加速" class="headerlink" title="强大的 GPU 加速"></a>强大的 GPU 加速<a class="post-anchor" href="#强大的-GPU-加速" aria-hidden="true"></a></h4><p>将拼接的字符串插入 DOM 后，出现了另外一个问题：滚动会很卡。猜想这是渲染问题，毕竟 34 万个单元格同时存在于界面中。</p><p>添加 <code>transform: translate3d(0, 0, 0) / translateZ(0)</code> 属性启动 GPU 渲染，即可解决这个渲染性能问题。再次感叹该属性的强大。🐂</p><p>后来，考虑到用户并不需要查看全部数据，只需展示部分数据让用户进行参考即可。我们对此只渲染前 30/50 行数据。这样即可提升用户体验，也能进一步优化性能。</p><h4 id="记得关闭-Vuex-的严格模式" class="post-heading"><a href="#记得关闭-Vuex-的严格模式" class="headerlink" title="记得关闭 Vuex 的严格模式"></a>记得关闭 Vuex 的严格模式<a class="post-anchor" href="#记得关闭-Vuex-的严格模式" aria-hidden="true"></a></h4><p>另外，由于自己学艺不精和粗心大意，忘记在生产环境关闭 Vuex 的『严格模式』。</p><p>Vuex 的严格模式要<strong>在生产环境中关闭</strong>，否则会对 state 树进行一个深观察 (deep watch)，产生不必要的性能损耗。也许在数据量少时，不会注意到这个问题。</p><p>还原当时的场景：导入 Excel 数据后，再进行交互（涉及 Vuex 的读写操作），需要等几秒才会响应，而直接通过纯 DOM 监听的事件则无此问题。由此，判断出是 Vuex 问题。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  strict: process.env.NODE_ENV !== <span class="string">'production'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="多进程！！！" class="post-heading"><a href="#多进程！！！" class="headerlink" title="多进程！！！"></a>多进程！！！<a class="post-anchor" href="#多进程！！！" aria-hidden="true"></a></h2><p>前面说道，JavaScript 天生单线程，即使再快，对于数据量较大时，也会出现拒绝响应的问题。因此需要 Web Worker 或类似的方案去解决。</p><p>在这里我不选择 Web worker 的原因有如下几点：</p><ol><li>有其它更好的替代方案：一个主进程能创建多个渲染进程，通过 IPC 即可进行数据交互；</li><li>Electron 不支持 Web Worker！(当然，可能会在新版本支持，最新信息请关注官方)</li></ol><p>Electron 作者在 2014.11.7 在《state of web worker support?》 issue 中回复了以下这一段：</p><blockquote><p>Node integration doesn’t work in web workers, and there is no plan to do. Workers in Chromium are implemented by starting a new thread, and Node is not thread safe. Back in past we had tried to add node integration to web workers in Atom, but it crashed too easily so we gave up on it.</p></blockquote><p>因此，我们最终采用了创建一个新的渲染进程 <code>background process</code> 进行处理数据。由 Electron 章节可知，每个 Electron 渲染进程是独立的，因此它们不会互相影响。但这也带来了一个问题：它们不能相互通讯？</p><p>错！下面有 3 种方式进行通讯：</p><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noopener">Storage API</a>：对某个标签页的 localStorage/sessionStorage 对象进行增删改时，其他标签页能通过 window.storage 事件监听到。</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API" target="_blank" rel="noopener">IndexedDB</a>：IndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。</li><li>通过主进程作为中转站：设主界面的渲染进程是 A，<code>background process</code> 是 B，那么 A 先将 Excel 数据传递到主进程，然后主进程再转发到 B。B 处理完后再原路返回，具体如下图。当然，也可以将数据存储在主进程中，然后在多个渲染进程中使用 remote 模块来访问它。</li></ol><p>该工具采用了第三种方式的第一种情况：<br><img src="//misc.aotu.io/JChehe/2016-11-15-xcel/multiprocess.jpg" alt="Multiprocessing"></p><p>1、主页面渲染进程 A 的代码如下：<br></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//①</span></span><br><span class="line">ipcRenderer.send(<span class="string">'filter-start'</span>, &#123;</span><br><span class="line">    filterTagList: <span class="keyword">this</span>.filterTagList,</span><br><span class="line">	filterWay: <span class="keyword">this</span>.filterWay,</span><br><span class="line">	curActiveSheetName: <span class="keyword">this</span>.activeSheet.name</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ⑥ 在某处接收 filter-response 事件</span></span><br><span class="line">ipcRenderer.on(<span class="string">"filter-response"</span>, (arg) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 得到处理数据</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>2、作为中转站的主进程的代码如下：<br></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>②</span><br><span class="line">ipcMain.<span class="literal">on</span>(<span class="string">"filter-start"</span>, <span class="function"><span class="params">(event, arg)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="regexp">//</span> webContents 用于渲染和控制 web page</span><br><span class="line">    backgroundWindow.webContents.send(<span class="string">"filter-start"</span>, arg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> ⑤ 用于接收返回事件</span><br><span class="line">ipcMain.<span class="literal">on</span>(<span class="string">"filter-response"</span>, <span class="function"><span class="params">(event, arg)</span> =&gt;</span> &#123;</span><br><span class="line">    mainWindow.webContents.send(<span class="string">"filter-response"</span>, arg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>3、处理繁重数据的 <code>background process</code> 渲染进程 B 的代码如下：<br></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ③</span></span><br><span class="line"><span class="selector-tag">ipcRenderer</span><span class="selector-class">.on</span>(<span class="string">'filter-start'</span>, (event, arg) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 进行运算</span></span><br><span class="line">    ... </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ④ 运算完毕后，再通过 IPC 原路返回。主进程和渲染进程 A 也要建立相应的监听事件</span></span><br><span class="line">    <span class="selector-tag">ipcRenderer</span><span class="selector-class">.send</span>(<span class="string">'filter-response'</span>, &#123;</span><br><span class="line">        <span class="attribute">filRow</span>: tempFilRow</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p>至此，我们将『读取文件』、『过滤数据』和『导出文件』三大耗时的数据操作均转移到了 <code>background process</code> 中处理。</p><p>这里，我们只创建了一个 <code>background process</code>，如果想要做得更极致，我们可以新建『CPU 线程数- 1 』 个的 <code>background process</code> 同时对数据进行处理，然后在主进程对处理后数据进行拼接，最后再将拼接后的数据返回到主页面的渲染进程。这样就可以充分榨干 CPU 了。当然，在此笔者不会进行这个优化。</p><blockquote><p>不要为了优化而优化，否则得不偿失。 —— 某网友</p></blockquote><h3 id="内存占有量过大" class="post-heading"><a href="#内存占有量过大" class="headerlink" title="内存占有量过大"></a>内存占有量过大<a class="post-anchor" href="#内存占有量过大" aria-hidden="true"></a></h3><p>解决了执行效率和渲染问题后，发现也存在内存占用量过大的问题。当时猜测是以下几个原因：</p><ol><li>三大耗时操作均放置在 <code>background process</code> 处理。在通讯传递数据的过程中，由于不是共享内存（因为 IPC 是基于 Socket 的），导致出现多份数据副本（在写这篇文章时才有了这相对确切的答案）。</li><li>Vuex 是以一个全局单例的模式进行管理，但它会是不是对数据做了某些封装，而导致性能的损耗呢？</li><li>由于 JavaScript 目前不具有主动回收资源的能力，所以只能主动对闲置对象设置为 <code>null</code>，然后等待 GC 回收。</li></ol><blockquote><p>由于 Chromium 采用多进程架构，因此会涉及到进程间通信问题。Browser 进程在启动 Render 进程的过程中会建立一个以 UNIX Socket 为基础的 IPC 通道。有了 IPC 通道之后，接下来 Browser 进程与 Render 进程就以消息的形式进行通信。我们将这种消息称为 IPC 消息，以区别于线程消息循环中的消息。<br>——<a href="http://blog.csdn.net/luoshengyang/article/details/47822689" target="_blank" rel="noopener">《Chromium的IPC消息发送、接收和分发机制分析》</a></p></blockquote><p>定义：为了易于理解，以下『Excel 数据』均指 Excel 的全部有效单元格转为 JSON 格式后的数据。</p><p>最容易处理的无疑是第三点，手动将不再需要的变量及时设置为 <code>null</code>，但效果并不明显。</p><p>后来，通过操作系统的『活动监视器』（Windows 上是任务管理器）对该工具的每阶段（打开时、导入文件时、筛选时和导出时）进行粗略的内存分析，得到以下报告：</p><p>—————- S：报告分割线 —————-<br>经观察，主要耗内存的是<strong>页面渲染进程</strong>。下面通过截图说明：<br><code>PID 15243</code> 是主进程<br><code>PID 15246</code> 是页面渲染进程<br><code>PID 15248</code> 是 background 渲染进程</p><p>a、首次启动程序时（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）</p><p><img src="https://img20.360buyimg.com/ling/jfs/t22528/169/401386936/20550/9088318e/5b2e3d95N5f402373.png" alt="启动程序时"></p><p>b、导入文件（第 5 行是主进程；第 2 行是页面渲染进程；第 4 行是 background 渲染进程 ）<br><img src="https://img14.360buyimg.com/ling/jfs/t20314/236/1602619966/22609/45b1df6e/5b2e3dabN0676e8d1.png" alt="导入文件时"></p><p>c、筛选数据（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）<br><img src="https://img14.360buyimg.com/ling/jfs/t22192/322/1574073289/21531/33f14a3/5b2e3dbaN5a9f3a6d.png" alt="筛选数据时"></p><p>由于 JavaScript 目前不具有主动回收资源的功能，所以只能主动将对象设置为 <code>null</code>，然后等待 GC 回收。</p><p>因此，经过一段时间等待后，内存占用如下：<br>d、一段时间后（第 4 行是主进程；第 1 行是页面渲染进程；第 3 行是 background 渲染进程 ）<br><img src="https://img10.360buyimg.com/ling/jfs/t21439/62/1600874642/20459/22a0dc08/5b2e3dc5N2a30be1a.png" alt="一段时间后"></p><p>由上述可得，页面渲染进程由于页面元素和 Vue 等 UI 相关资源是固定的，占用内存较大且不能回收。主进程占用资源也不能得到很好释放，暂时不知道原因，而 background 渲染进程则较好地释放资源。</p><p>—————- E：报告分割线 —————-</p><p>根据报告，初步得出的结论是 Vue 和通讯时占用资源较大。</p><p>根据该工具的实际应用场景：Excel 数据只在『导入』和『过滤后』两个阶段需要展示，而且展示的是通过 JavaScript 拼接的 HTML 字符串所构成的 DOM 而已。因此将表格数据放置在 Vuex 中，有点滥用资源的嫌疑。</p><p>另外，在 <code>background process</code> 中也有存有一份 Excel 数据副本。因此，索性只在 <code>background process</code> 存储一份 Excel 数据，然后每当数据变化时，通过 IPC 让 <code>background process</code> 返回拼接好的 HTML 字符串即可。这样一来，内存占有量立刻下降许多。另外，这也是一个一举多得的优化：</p><ol><li>字符串拼接操作也转移到了 <code>background process</code>，页面渲染进程进一步减少耗时的操作；</li><li>内存占有量大大减小，响应速度也得到了提升。</li></ol><p>其实，这也有点像 Vuex 的『全局单例模式管理』，一份数据就好。</p><p>当然，对于 Excel 的基本信息，如行列数、SheetName、标题组等均依然保存在 Vuex。</p><p>优化后的内存占有量如下图。与上述报告的第三张图相比（同一阶段），内存占有量下降了 44.419%：<br><img src="https://img11.360buyimg.com/ling/jfs/t23707/296/382906652/26209/c67155f0/5b2e3dcfN1c2daa62.png" alt="优化后内存占有量"><br>另外，对于不需要响应的数据，可通过 <code>Object.freeze()</code> 冻结起来。这也是一种优化手段。但该工具目前并没有应用到。</p><p>至此，优化部分也阐述完毕了！</p><hr><p>该工具目前是开源的，欢迎大家使用或推荐给用研组等有需要的人。</p><p>你们的反馈（可提交 <a href="https://github.com/o2team/xcel/issues" target="_blank" rel="noopener">issues</a> / <a href="https://github.com/o2team/xcel/pulls" target="_blank" rel="noopener">pull request</a>）能让这个工具在使用和功能上不断完善。</p><p>最后，感谢 <a href="https://github.com/mamboer" target="_blank" rel="noopener">LV</a> 在产品规划、界面设计和优化上的强力支持。全文完！</p><div class="post-tags" style="display:none"><a href="/tags/node/">node</a> <a href="/tags/excel/">excel</a> <a href="/tags/data-clening/">data-clening</a> <a href="/tags/electron/">electron</a> <a href="/tags/js-xlsx/">js-xlsx</a> <a href="/tags/vue/">vue</a></div><div class="post-categories" style="display:none"><a href="/cates/项目总结/">项目总结</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="https://github.com/JChehe">Jc</a> 原创提供。如若转载，请注明出处：凹凸实验室（<a href="/notes/2016/11/15/xcel/">https://aotu.io/notes/2016/11/15/xcel/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2021-02-02T07:48:05.238Z">上次更新：2021-02-02 15:48:05</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2016/11/17/regexp-theory/" title="正则表达式理论篇">正则表达式理论篇 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2016/11/14/booklist-for-every-programmer/" title="漫漫编程路上必读的7本书"><i class="fa fa-chevron-left"></i> 漫漫编程路上必读的7本书</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"bm90ZXMvMjAxNi8xMS8xNS94Y2VsLw==",owner:"o2team",repo:"o2team.github.io",title:"XCel 项目总结 - Electron 与 Vue 的性能优化",body:"https://aotu.io/notes/2016/11/15/xcel/index.html\n\nXCel 是一款基于用研组需求的 Excel 数据过滤工具，本文将分享 Electron、Vue 等相关涉及技术的基本知识和性能优化经验。这也许是Jc的2016年最后一篇文章，且看且不珍惜。",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["JChehe"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdrd.jd.com" target="_blank" title="京东零售设计服务平台">京东零售设计服务平台</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2021. All Rights Reserved.</p><p><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>