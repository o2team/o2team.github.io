<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>React 入门儿 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="技术,前端,React,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2020/11/12/react-indoor/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="谁都没有看见过风，更不用说你和我了。但是当纸币在飘的时候，我们知道那是风在数钱。  React 影响着我们工作的方方面面，我们每天都在使用它，只窥其表却难以窥其里。正所谓看不如写，本篇文章的目的就是从原理层面探究 React 是如何工作的。 工具在写文章之前，为了方便理解，我准备了一个懒人调试仓库 simple_react ，这个仓库将  benchmark  用例（只有两个 ^ ^）和 Rea"><meta name="keywords" content="React,前端,技术"><meta property="og:type" content="article"><meta property="og:title" content="React 入门儿"><meta property="og:url" content="https://aotu.io/notes/2020/11/12/react-indoor/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="谁都没有看见过风，更不用说你和我了。但是当纸币在飘的时候，我们知道那是风在数钱。  React 影响着我们工作的方方面面，我们每天都在使用它，只窥其表却难以窥其里。正所谓看不如写，本篇文章的目的就是从原理层面探究 React 是如何工作的。 工具在写文章之前，为了方便理解，我准备了一个懒人调试仓库 simple_react ，这个仓库将  benchmark  用例（只有两个 ^ ^）和 Rea"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://img11.360buyimg.com/ling/jfs/t1/136683/17/16826/28884/5fb8b62cE2f9f4cba/bf1649d3a0238025.png"><meta property="og:image" content="https://img11.360buyimg.com/ling/jfs/t1/123616/3/19615/109246/5fb8c0cdE2b1a2848/0a47db7bef39c043.png"><meta property="og:image" content="https://img14.360buyimg.com/ling/jfs/t1/134461/22/16700/98512/5fb8ce73Ea86427a2/55e9ab20d4dd1731.png"><meta property="og:image" content="https://img20.360buyimg.com/ling/jfs/t1/122851/26/20021/10658/5fbbbdebE314a4349/5e082a5b3ded4328.png"><meta property="og:image" content="https://img12.360buyimg.com/ling/jfs/t1/128064/14/19510/42749/5fba15e8E1c00dca2/f1bd2f6b8ce53ca8.png"><meta property="og:image" content="https://img30.360buyimg.com/ling/jfs/t1/151336/9/7644/85935/5fba22f6E6d4a0a30/9d15606d04b891e6.png"><meta property="og:image" content="https://img14.360buyimg.com/ling/jfs/t1/146083/13/15257/92531/5fba3093E68ec25bc/b189ae2c2eb7fe3e.jpg"><meta property="og:updated_time" content="2021-02-02T07:48:05.254Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="React 入门儿"><meta name="twitter:description" content="谁都没有看见过风，更不用说你和我了。但是当纸币在飘的时候，我们知道那是风在数钱。  React 影响着我们工作的方方面面，我们每天都在使用它，只窥其表却难以窥其里。正所谓看不如写，本篇文章的目的就是从原理层面探究 React 是如何工作的。 工具在写文章之前，为了方便理解，我准备了一个懒人调试仓库 simple_react ，这个仓库将  benchmark  用例（只有两个 ^ ^）和 Rea"><meta name="twitter:image" content="https://img11.360buyimg.com/ling/jfs/t1/136683/17/16826/28884/5fb8b62cE2f9f4cba/bf1649d3a0238025.png"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="https://img11.360buyimg.com/ling/jfs/t1/123708/39/19706/192563/5fbc7251E95ba3235/c3c04cc077eb7c54.jpg" alt="React 入门儿"></div><header class="post-hd"><h1 class="post-tit">React 入门儿</h1><div class="post-meta">by <a target="_blank" href="https://github.com/" class="post-author">風魔小次郎</a> on <span>2020-11-12</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>无</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><blockquote><p>谁都没有看见过风，更不用说你和我了。但是当纸币在飘的时候，我们知道那是风在数钱。</p></blockquote><p><strong>React</strong> 影响着我们工作的方方面面，我们每天都在使用它，只窥其表却难以窥其里。正所谓看不如写，本篇文章的目的就是从原理层面探究 <strong>React</strong> 是如何工作的。</p><h2 id="工具" class="post-heading"><a href="#工具" class="headerlink" title="工具"></a>工具<a class="post-anchor" href="#工具" aria-hidden="true"></a></h2><p>在写文章之前，为了方便理解，我准备了一个懒人调试仓库 <a href="https://github.com/XHFkindergarten/simple_react" target="_blank" rel="noopener">simple_react</a> ，这个仓库将 benchmark 用例（只有两个 ^ ^）和 <strong>React</strong> 源码共同放在 src 文件夹中，通过 snowpack 进行热更新，可以直接在源码中加入 log 和 debuger 进行调试。当然这里的“源码”并不是真的源码，因为 <strong>React</strong> 源码中充斥着巨量的 dev 代码和不明确的功能函数，所以我对源码进行了整理，用 typescript 对类型进行了规范，删除了大量和核心流程无关的代码（当然也误删了一些有关的 ^ ^）。</p><p>如果你只是希望了解 <strong>React</strong> 的运行流程而不是写一个可以用的框架的话，那么这个仓库完全可以满足你学习的需要。当然，这个仓库基于 React16.8 ，虽然这个版本并不包括当前的航道模型 Lane 等新特性，但是是我个人认为比较稳定且更适合阅读的一个版本。</p><p>（如果希望调试完整的源码，也可以参考 <a href="https://react.iamkasong.com/preparation/source.html#%E6%8B%89%E5%8F%96%E6%BA%90%E7%A0%81" target="_blank" rel="noopener">拉取源码</a> 通过 yarn link 来进行 debug）</p><h2 id="文章结构" class="post-heading"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构<a class="post-anchor" href="#文章结构" aria-hidden="true"></a></h2><ol><li>fiber 架构设计及首次渲染流程</li><li>事件委托机制</li><li>状态的更新</li><li>时间片</li></ol><p>在了解 <strong>React</strong> 是如何工作之前，我们应该确保了解几点有关 <strong>React</strong> 的基础知识。</p><h2 id="Why-Framework" class="post-heading"><a href="#Why-Framework" class="headerlink" title="Why Framework"></a>Why Framework<a class="post-anchor" href="#Why-Framework" aria-hidden="true"></a></h2><p>首先，我们需要知道使用框架对于开发的意义是什么。如果我们还处于远古时期使用纯 JS 的阶段，每次数据的改变都会引发组件的展示状态改变，因此我们需要去手动的操作 DOM 。如果在某一秒内，数据异步的连续改变了几十次，根据展示逻辑我们也需要连续对 DOM 进行几十次修改。频繁的 DOM 操作对网页性能的影响是很大的，当然，创建 DOM 元素和修改 DOM 元素的属性都不过分消耗性能，主要在于每次将新的 DOM 插入 document 都会导致浏览器重新计算布局属性，以及各个视图层、合并、渲染。所以，这样的代码性能是十分低下的。</p><p>可以试想这样一个场景。对于一个前端列表组件而言，当存在 3 条数据的时候展示 3 条，当存在 5 条数据的时候展示 5 条。也就是说 UI 的呈现在某种程度上必然会和数据存在某种逻辑关系。如果 JS 能够感知到关键数据的改变，使用一种高效的方式将 DOM 改写成与数据相对应的状态。那么于开发者而言，就可以专注于业务逻辑和数据的改变，工作效率也会大幅提高。</p><p>所以， <strong>框架</strong> 最核心的功能之一就是 <strong>高效地</strong> 达成 <strong>UI层和数据层的统一。</strong></p><h2 id="React-哲学" class="post-heading"><a href="#React-哲学" class="headerlink" title="React 哲学"></a>React 哲学<a class="post-anchor" href="#React-哲学" aria-hidden="true"></a></h2><p><strong>React</strong> 本身并不是框架， <strong>React</strong> 只是一个 <strong>JavaScript</strong> 库，他的作用是通过组件构建用户界面，属于 MVC 应用中的 View 视图层。 <strong>React</strong> 通过 props 和 state 来简化关键数据的存储，对于一个 react 组件函数而言，在 1 秒内可能被执行很多次。而每一次被执行，数据被注入 JSX ， JSX 并不是真实的 DOM ，在 <strong>React</strong> 中会被转换成 <code>React.createElement(type, props, children)</code> 函数，执行的结果就是 ReactElement 元素 ，也即是 <strong>虚拟DOM</strong> ，用来描述在浏览器的某一帧中，组件应该被呈现为什么样子。</p><h2 id="Virtual-Dom" class="post-heading"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom<a class="post-anchor" href="#Virtual-Dom" aria-hidden="true"></a></h2><p>VirtualDom 并非 <strong>React</strong> 专属，就像 redux 也可以在非 <strong>React</strong> 环境下使用一样，它们只是一种设计的思路。</p><p>事实上， <strong>React</strong> 在使用 fiber 架构之前的 Virtual Dom 和 diff 过程要相对直观一些。但是在引入了 fiber 架构之后整个流程变得冗长，如果单纯想了解 VirtualDom 和 diff 过程的原理也可以通过 <a href="https://github.com/livoras/simple-virtual-dom" target="_blank" rel="noopener">simple-virtual-dom</a> 这个仓库来学习。</p><p>VirtualDom 的本质是利用 <strong>JS变量</strong> 对真实 DOM 进行抽象，既然每一次操作 DOM 都可能触发浏览器的重排消耗性能，那么就可以使用 VirtualDom 来缓存当前组件状态，对用户交互和数据的变动进行批次处理，直接计算出每一帧页面应该呈现的最终状态，而这个状态是以 <strong>JS变量</strong> 的形式存在于内存中的。所以通过 VirtualDom 既能够保证用户看到的每一帧都响应了数据的变化，又能节约性能保证浏览器不出现卡顿。</p><h1 id="第一次渲染-First-Render" class="post-heading"><a href="#第一次渲染-First-Render" class="headerlink" title="第一次渲染 First Render"></a>第一次渲染 First Render<a class="post-anchor" href="#第一次渲染-First-Render" aria-hidden="true"></a></h1><p>首先我们应该注意到 React(浏览器环境) 代码的入口 <strong>render</strong> 函数</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, domContainer)</span></span><br></pre></td></tr></table></figure><p>这个 render 过程中， <strong>React</strong> 需要做到的是根据用户创造的 JSX 语法，构建出一个虚拟的树结构（也就是 ReactElement 和 Fiber ）来表示用户 <strong>期望中</strong> 页面中的元素结构。当然对于这个过程相对并不复杂（误），因为此时的 document 内还是一片虚无。就思路上而言，只需要根据虚拟 DOM 节点生成真实的 DOM 元素然后插入 document ，第一次渲染就算圆满完成。</p><h2 id="createReactElement" class="post-heading"><a href="#createReactElement" class="headerlink" title="createReactElement"></a>createReactElement<a class="post-anchor" href="#createReactElement" aria-hidden="true"></a></h2><p>通常我们会通过 Babel 将 JSX 转换为一个 JS 执行函数。例如我们在 React 环境下用 JSX 中写了一个标题组件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">'title'</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>Class Component<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><p>那么这个组件被 Babel 转换之后将会是</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(<span class="string">'h1'</span>, &#123; <span class="string">className:</span> <span class="string">'title'</span> &#125;, [</span><br><span class="line">	React.createElement(<span class="string">'div'</span>, <span class="literal">null</span>, [ <span class="string">'Class Component'</span> ]</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>传统编译讲究一个 JSON 化，当然 JSX 和 <strong>React</strong> 也没有什么关系， JSX 只是 <strong>React</strong> 推荐的一种拓展语法。当然你也可以不用 JSX 直接使用 React.createElement 函数，但是对比上面的两种写法你就也能知道，使用纯 JS 的心智成本会比简明可见的 JSX 高多少。我们可以看出， React.createElement 需要接收 3 个参数，分别是 DOM 元素的标签名，属性对象以及一个子元素数组，返回值则是一个 ReactElement 对象。</p><p>事实上， JSX 编译后的 json 结构本身就是一个对象，即使不执行 React.createElement 函数也已经初步可以使用了。那么在这个函数中我们做了什么呢。</p><p>一个 ReactElement 元素主要有 5 个关键属性，我们都知道要构建成一个页面需要通过 html 描述元素的类型和结构，通过 style 和 class 去描述元素的样式呈现，通过 js 和绑定事件来触发交互事件和页面更新。</p><p>所以最重要的是第一个属性，元素类型 <code>type</code> 。如果这个元素是一个纯 html 标签元素，例如 div ，那么 type 将会是字符串 div ，如果是一个 <strong>React</strong> 组件，例如</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		&lt;div&gt;Hello, World!<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么 <code>type</code> 的值将会指向 App 函数，当然 Class组件 也一样（众所周知 ES6 的 Class 语法本身就是函数以及原型链构成的语法糖）</p><p>第二个属性是 <code>props</code> ，我们在 html 标签中写入的大部分属性都会被收集在 <code>props</code> 中，例如 id 、 className 、 style 、 children 、点击事件等等。</p><p>第三个第四个属性分别是 <code>key</code> 和 <code>ref</code> ，其中 <code>key</code> 在数组的处理和 diff 过程中有重要作用，而 <code>ref</code> 则是引用标识，在这里就先不做过多介绍。</p><p>最后一个属性是 <code>$$typeof</code> ，这个属性会指向 <code>Symbol(React.element)</code> 。作为 <strong>React</strong> 元素的唯一标识的同时，这个标签也承担了安全方面的功能。我们已经知道了所谓的 ReactElement 其实就是一个 JS 对象。那么如果有用户恶意的向服务端数据库中存入了某个有侵入性功能的 <strong>伪React</strong> 对象，在实际渲染过程中被当做页面元素渲染，那么将有可能威胁到用户的安全。而 <code>Symbol</code> 是无法在数据库中被存储的，换句话说， <strong>React</strong> 所渲染的所有元素，都必须是由 JSX 编译的拥有 <code>Symbol</code> 标识的元素。（如果在低版本不支持 Symbol 的浏览器中，将会使用字符串替代，也就没有这层安排保护了）</p><p>ok，接下来回到 render 函数。在这个函数中到底发生了什么呢，简单来说就是创建 <code>Root</code> 结构。</p><p><img src="https://img11.360buyimg.com/ling/jfs/t1/136683/17/16826/28884/5fb8b62cE2f9f4cba/bf1649d3a0238025.png" alt="https://img11.360buyimg.com/ling/jfs/t1/136683/17/16826/28884/5fb8b62cE2f9f4cba/bf1649d3a0238025.png"></p><h1 id="enqueueUpdate" class="post-heading"><a href="#enqueueUpdate" class="headerlink" title="enqueueUpdate"></a>enqueueUpdate<a class="post-anchor" href="#enqueueUpdate" aria-hidden="true"></a></h1><p>从设计者的角度，根据 <strong>单一职责原则</strong> 和 <strong>开闭口原则</strong> 需要有与函数体解耦的数据结构来告诉 <strong>React</strong> 应该怎么操作 fiber 。而不是初次渲染写一套逻辑，第二次渲染写一套逻辑。因此， fiber 上有了更新队列 <code>UpdateQueue</code> 和 更新链表 <code>Update</code> 结构</p><p>如果查看一下相关的定义就会发现，更新队列 <code>updateQueue</code> 是多个更新组成的链表结构，而 <code>update</code> 的更新也是一个链表，至于为什么是这样设计，试想在一个 Class Component 的更新函数中连续执行了 3 次 setState ，与其将其作为 3 个更新挂载到组件上，不如提供一种更小粒度的控制方式。一句话概括就是， setState 级别的小更新合并成一个状态更新，组件中的多个状态更新在组件的更新队列中合并，就能够计算出组件的新状态 <code>newState</code>。</p><p>对于初次渲染而言，只需要在第一个 fiber 上，挂载一个 <code>update</code> 标识这是一个初次渲染的 fiber 即可。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 更新根节点</span><br><span class="line">export <span class="keyword">function</span> ScheduleRootUpdate (</span><br><span class="line">  <span class="keyword">current</span>: Fiber,</span><br><span class="line">  element: ReactElement,</span><br><span class="line">  expirationTime: number,</span><br><span class="line">  suspenseConfig: SuspenseConfig | <span class="keyword">null</span>,</span><br><span class="line">  callback?: <span class="keyword">Function</span></span><br><span class="line">) &#123;</span><br><span class="line">  // 创建一个<span class="keyword">update</span>实例</span><br><span class="line">  const <span class="keyword">update</span> = createUpdate(expirationTime, suspenseConfig)</span><br><span class="line">  // 对于作用在根节点上的 react element</span><br><span class="line">  <span class="keyword">update</span>.payload = &#123;</span><br><span class="line">    element</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将 <span class="keyword">update</span> 挂载到根 fiber 的 updateQueue 属性上</span><br><span class="line">  enqueueUpdate(</span><br><span class="line">    <span class="keyword">current</span>,</span><br><span class="line">    <span class="keyword">update</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ScheduleWork(</span><br><span class="line">    <span class="keyword">current</span>,</span><br><span class="line">    expirationTime</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fiber" class="post-heading"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber<a class="post-anchor" href="#Fiber" aria-hidden="true"></a></h2><p>作为整个 <strong>Fiber架构</strong> 中最核心的设计， Fiber 被设计成了链表结构。</p><ul><li>child 指向当前节点的第一个子元素</li><li>return 指向当前节点的父元素</li><li>sibling 指向同级的下一个兄弟节点</li></ul><p>如果是 React16 之前的树状结构，就需要通过 DFS 深度遍历来查找每一个节点。而现在只需要将指针按照 child → sibling → return 的优先级移动，就可以处理所有的节点</p><p><img src="https://img11.360buyimg.com/ling/jfs/t1/123616/3/19615/109246/5fb8c0cdE2b1a2848/0a47db7bef39c043.png" alt="https://img11.360buyimg.com/ling/jfs/t1/123616/3/19615/109246/5fb8c0cdE2b1a2848/0a47db7bef39c043.png"></p><p>这样设计还有一个好处就是在 <strong>React</strong> 工作的时候只需要使用一个全局变量作为指针在链表中不断移动，如果出现用户输入或其他优先级更高的任务就可以 <strong>暂停</strong> 当前工作，其他任务结束后只需要根据指针的位置继续向下移动就可以继续之前的工作。指针移动的规律可以归纳为 <strong>自顶向下，从左到右 。</strong></p><p>康康 fiber 的基本结构</p><p><img src="https://img14.360buyimg.com/ling/jfs/t1/134461/22/16700/98512/5fb8ce73Ea86427a2/55e9ab20d4dd1731.png" alt="https://img14.360buyimg.com/ling/jfs/t1/134461/22/16700/98512/5fb8ce73Ea86427a2/55e9ab20d4dd1731.png"></p><p>其中</p><ul><li><strong>tag</strong> fiber 的类型 ，例如函数组件，类组件，原生组件， <strong>Portal</strong> 等。</li><li><strong>type</strong> React元素 类型 详见上方 createElement。</li><li><strong>alternate</strong> 代表双向缓冲对象（看后面）。</li><li><strong>effectTag</strong> 代表这个 fiber 在下一次渲染中将会被如何处理。例如只需要插入，那么这个值中会包含 Placement ，如果需要被删除，那么将会包含 Deletion 。</li><li><strong>expirationTime</strong> 过期时间，过期时间越靠前，就代表这个 fiber 的优先级越高。</li><li><strong>firstEffect</strong> 和 <strong>lastEffect</strong> 的类型都和 fiber 一样，同样是链表结构，通过 <strong>nextEffect</strong> 来连接。代表着即将更新的 fiber 状态</li><li><strong>memorizeState</strong> 和 <strong>memorizeProps</strong> 代表在上次渲染中组件的 props 和 state 。如果成功更新，那么新的 <strong>pendingProps</strong> 和 newState 将会替代这两个变量的值</li><li><strong>ref</strong> 引用标识</li><li><strong>stateNode</strong> 代表这个 fiber 节点对应的真实状态<ul><li>对于原生组件，这个值指向一个 dom 节点（虽然已经被创建了，但不代表就被插入了 document ）</li><li>对于类组件，这个值指向对应的类实例</li><li>对于函数组件，这个值指向 <strong>Null</strong></li><li>对于 RootFiber，这个值指向 <strong>FiberRoot</strong> （如图）</li></ul></li></ul><p>接下来是初次渲染的几个核心步骤，因为是初次渲染，核心任务就是将首屏元素渲染到页面上，所以这个过程将会是同步的。</p><h2 id="PrepareFreshStack" class="post-heading"><a href="#PrepareFreshStack" class="headerlink" title="PrepareFreshStack"></a>PrepareFreshStack<a class="post-anchor" href="#PrepareFreshStack" aria-hidden="true"></a></h2><p>因为笔者是土货没学过英语，百度了下发现是 <strong>准备干净的栈</strong> 的意思。结合了下流程，可以看出这一步的作用是在真正工作之前做一些准备，例如初始化一些变量，放弃之前未完成的工作，以及最重要的—— <strong>创建双向缓冲变量</strong> WorkInProgress</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> workInProgress: Fiber | <span class="literal">null</span> = <span class="literal">null</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">prepareFreshStack</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 重置根节点的finishWork</span></span><br><span class="line">  root.finishedWork = <span class="literal">null</span></span><br><span class="line">  root.finishedExpirationTime = ExpirationTime.NoWork</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果已经存在了WIP，说明存在未完成的任务</span></span><br><span class="line">    <span class="comment">// 向上找到它的root fiber</span></span><br><span class="line">    <span class="keyword">let</span> interruptedWork = workInProgress.return</span><br><span class="line">    <span class="keyword">while</span> (interruptedWork !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// unwindInterruptedWork // 抹去未完成的任务</span></span><br><span class="line">      unwindInterruptedWork(interruptedWork)</span><br><span class="line">      interruptedWork = interruptedWork.return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  workInProgressRoot = root</span><br><span class="line">  <span class="comment">// 创建双向缓冲对象</span></span><br><span class="line">  workInProgress = createWorkInProgress(root.current, <span class="literal">null</span>, expirationTime)</span><br><span class="line">  renderExpirationTime = expirationTime</span><br><span class="line">  workInProgressRootExitStatus = RootExitStatus.RootImcomplete</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双向缓冲变量-WorkInProgress" class="post-heading"><a href="#双向缓冲变量-WorkInProgress" class="headerlink" title="双向缓冲变量 WorkInProgress"></a>双向缓冲变量 WorkInProgress<a class="post-anchor" href="#双向缓冲变量-WorkInProgress" aria-hidden="true"></a></h1><p>这里简称 WIP 好了，与之对应的是 current ， current 代表的是当前页面上呈现的组件对应的 fiber 节点，你可以将其类比为 git 中的 master 分支，它代表的是已经对外的状态。而 WIP 则代表了一个 pending 的状态，也就是下一帧屏幕将要呈现的状态，就像是从 master 拉出来的一个 feature 分支，我们可以在这个分支上做任意的更改。最终协调完毕，将 WIP 的结果渲染到了页面上，按照页面内容对应 current 的原则， current 将会指向 WIP ，也就是说， WIP 取代了之前的 current （ git 的 master 分支）。</p><p>在这之前 current 和 WIP 的 alternate 字段分别指向彼此。</p><p><img src="https://img20.360buyimg.com/ling/jfs/t1/122851/26/20021/10658/5fbbbdebE314a4349/5e082a5b3ded4328.png" alt="https://img20.360buyimg.com/ling/jfs/t1/122851/26/20021/10658/5fbbbdebE314a4349/5e082a5b3ded4328.png"></p><p>那么 WIP 是如何被创造出来的呢：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据已有 fiber 生成一个 workInProgress 节点</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createWorkInProgress</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  expirationTime</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> workInProgress = current.alternate</span><br><span class="line">  <span class="keyword">if</span> (workInProgress === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果当前fiber没有alternate</span></span><br><span class="line">    <span class="comment">// tip: 这里使用的是“双缓冲池技术”，因为我们最多需要一棵树的两个实例。</span></span><br><span class="line">    <span class="comment">// tip: 我们可以自由的复用未使用的节点</span></span><br><span class="line">    <span class="comment">// tip: 这是异步创建的，避免使用额外的对象</span></span><br><span class="line">    <span class="comment">// tip: 这同样支持我们释放额外的内存（如果需要的话</span></span><br><span class="line">    workInProgress = createFiber(</span><br><span class="line">      current.tag,</span><br><span class="line">      pendingProps,</span><br><span class="line">      current.key,</span><br><span class="line">      current.mode</span><br><span class="line">    )</span><br><span class="line">    workInProgress.elementType = current.elementType</span><br><span class="line">    workInProgress.type = current.type</span><br><span class="line">    workInProgress.stateNode = current.stateNode</span><br><span class="line"></span><br><span class="line">    workInProgress.alternate = current</span><br><span class="line">    current.alternate = workInProgress</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 我们已经有了一个 WIP</span></span><br><span class="line">    workInProgress.pendingProps = pendingProps</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 effectTag</span></span><br><span class="line">    workInProgress.effectTag = EffectTag.NoEffect</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置 effect 链表</span></span><br><span class="line">    workInProgress.nextEffect = <span class="literal">null</span></span><br><span class="line">    workInProgress.firstEffect = <span class="literal">null</span></span><br><span class="line">    workInProgress.lastEffect = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可以看出 WIP 其实就是继承了 current 的核心属性，但是去除了一些副作用和工作记录的 <strong>干净</strong> 的 fiber。</p><h1 id="工作循环-WorkLoop" class="post-heading"><a href="#工作循环-WorkLoop" class="headerlink" title="工作循环 WorkLoop"></a>工作循环 WorkLoop<a class="post-anchor" href="#工作循环-WorkLoop" aria-hidden="true"></a></h1><p>在工作循环中，将会执行一个 <code>while</code> 语句，每执行一次循环，都会完成对一个 <code>fiber</code> 节点的处理。在 workLoop 模块中有一个指针 workInProgress 指向当前正在处理的 fiber ，它会不断向链表的尾部移动，直到指向的值为 null ，就停止这部分工作， workLoop 的部分也就结束了。</p><p>每处理一个 fiber 节点都是一个工作单元，结束了一个工作单元后 <strong>React</strong> 会进行一次判断，是否需要暂停工作检查有没有更高优先级的用户交互进来。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行工作直到 Scheduler 要求我们 yield</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    workInProgress = performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳出条件只有：</p><ol><li>所有 fiber 都已经被遍历结束了</li><li>当前线程的使用权移交给了外部任务队列</li></ol><p>但是我们现在讨论的是第一次渲染，触屏渲染的优先级高于一切，所以并不存在第二个限制条件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 只要没有完成reconcile就一直执行</span></span><br><span class="line">  <span class="keyword">while</span>(workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    workInProgress = performUnitOfWork(workInProgress <span class="keyword">as</span> Fiber)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PerformUnitOfWork-amp-beginWork" class="post-heading"><a href="#PerformUnitOfWork-amp-beginWork" class="headerlink" title="PerformUnitOfWork &amp; beginWork"></a>PerformUnitOfWork &amp; beginWork<a class="post-anchor" href="#PerformUnitOfWork-amp-beginWork" aria-hidden="true"></a></h2><p>单元工作 performUnitOfWork 的主要工作是通过 beginWork 来完成。 beginWork 的核心工作是通过判断 fiber.tag 判断当前的 fiber 代表的是一个类组件、函数组件还是原生组件，并且针对它们做一些特殊处理。这一切都是为了最终步骤：操作真实 <strong>DOM</strong> 做准备，即通过改变 fiber.effectTag 和 pendingProps 告诉后面的 commitRoot 函数应该对真实 <strong>DOM</strong> 进行怎样的改写。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="comment">// RootFiber</span></span><br><span class="line">    <span class="keyword">case</span> WorkTag.HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current <span class="keyword">as</span> Fiber, workInProgress, renderExpirationTime)</span><br><span class="line">    <span class="comment">// class 组件</span></span><br><span class="line">    <span class="keyword">case</span> WorkTag.ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type</span><br><span class="line">      <span class="keyword">const</span> resolvedProps = workInProgress.pendingProps</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderExpirationTime</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处就以 Class 组件为例，查看一下具体是如何构建的。</p><p>之前有提过，对于类组件而言， fiber.stateNode 会指向这个类之前构造过的实例。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新Class组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpiration: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果这个 class 组件被渲染过，stateNode 会指向类实例</span></span><br><span class="line">  <span class="comment">// 否则 stateNode 指向 null</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode</span><br><span class="line"><span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果没有构造过类实例</span></span><br><span class="line">	...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 如果构造过类实例</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成 render 的构建，将得到的 react 元素和已有元素进行调和</span></span><br><span class="line"><span class="keyword">const</span> nextUnitOfWork = finishClassComponent(</span><br><span class="line">  current,</span><br><span class="line">  workInProgress,</span><br><span class="line">  Component,</span><br><span class="line">  shouldUpdate,</span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  renderExpiration</span><br><span class="line">)</span><br><span class="line"><span class="keyword">return</span> nextUnitOfWork</span><br></pre></td></tr></table></figure><p>如果这个 fiber 并没有构建过类实例的话，就会调用它的构建函数，并且将更新器 updater 挂载到这个类实例上。（处理 setState 逻辑用的，事实上所有的类组件实例上的更新器都是同一个对象，后面会提到）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 这个 class 第一次渲染</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 删除 current 和 WIP 之间的指针</span></span><br><span class="line">    current.alternate = <span class="literal">null</span></span><br><span class="line">    workInProgress.alternate = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 插入操作</span></span><br><span class="line">    workInProgress.effectTag |= EffectTag.Placement</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 调用构造函数，创造新的类实例</span></span><br><span class="line">  <span class="comment">// 给予类实例的某个指针指向更新器 updater</span></span><br><span class="line">  constructClassInstance(</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    renderExpiration</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将属性挂载到类实例上，并且触发多个生命周期</span></span><br><span class="line">  mountClassInstance(</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    renderExpiration </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果实例已经存在，就需要对比新旧 props 和 state ，判断是否需要更新组件（万一写了 shouldComponentUpdate 呢）。并且触发一些更新时的生命周期钩子，例如 getDerivedStateFromProps 等等。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 已经 render 过了，更新</span></span><br><span class="line">  shouldUpdate = updateClassInstance(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    renderExpiration</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属性计算完毕后，调用类的 <code>render</code> 函数获取最终的 ReactElement ，打上 Performed 标记，代表这个类在本次渲染中已经执行过了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完成Class组件的构建</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">finishClassComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  shouldUpdate: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  hasContext: boolean,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpiration: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误 边界捕获</span></span><br><span class="line">  <span class="keyword">const</span> didCaptureError = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!shouldUpdate &amp;&amp; !didCaptureError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasContext) &#123;</span><br><span class="line">      <span class="comment">// 抛出问题</span></span><br><span class="line">      <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        renderExpiration</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren</span><br><span class="line"></span><br><span class="line">  nextChildren = instance.render()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记为已完成</span></span><br><span class="line">  workInProgress.effectTag |= EffectTag.PerformedWork</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始调和 reconcile</span></span><br><span class="line">  reconcileChildren(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    nextChildren,</span><br><span class="line">    renderExpiration</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调和过程</p><p>如果还记得之前的内容的话，我们在一切工作开始之前只是构建了第一个根节点 fiberRoot 和第一个无意义的空 root ，而在单个元素的调和过程 reconcileSingleElement 中会根据之前 render 得到的 ReactElement 元素构建出对应的 fiber 并且插入到整个 fiber 链表中去。</p><p>并且通过 placeSingleChild 给这个 fiber 的 effectTag 打上 Placement 的标签，拥有 Placement 标记后这里的工作就完成了，可以将 fiber 指针移动到下一个节点了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理对象类型(单个节点)</span></span><br><span class="line"><span class="keyword">const</span> isObjectType = isObject(newChild) &amp;&amp; !isNull(newChild)</span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">if</span> (isObjectType) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (newChild.$$<span class="keyword">typeof</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> REACT_ELEMENT_TYPE: &#123;</span><br><span class="line">      <span class="comment">// 在递归调和结束，向上回溯的过程中</span></span><br><span class="line">      <span class="comment">// 给这个 fiber 节点打上 Placement 的 Tag</span></span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">        reconcileSingleElement(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          expirationTime</span><br><span class="line">        )</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还有 Fragment 等类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这时子元素是字符串或者数字，按照文字节点来处理</span></span><br><span class="line"><span class="comment">// 值得一提的是，如果元素的子元素是纯文字节点</span></span><br><span class="line"><span class="comment">// 那么这些文字不会被转换成 fiber</span></span><br><span class="line"><span class="comment">// 而是作为父元素的 prop 来处理</span></span><br><span class="line"><span class="keyword">if</span> (isString(newChild) || isNumber(newChild)) &#123;</span><br><span class="line">  <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">    reconcileSingleTextNode(</span><br><span class="line">      returnFiber,</span><br><span class="line">      currentFirstChild,</span><br><span class="line">      <span class="string">''</span> + newChild,</span><br><span class="line">      expirationTime</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line"><span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">  <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">    returnFiber,</span><br><span class="line">    currentFirstChild,</span><br><span class="line">    newChild,</span><br><span class="line">    expirationTime</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文章篇幅有限，对于函数组件和原生组件这里就不做过多介绍。假设我们已经完成了对于所有 WIP 的构建和调和过程，对于第一次构建而言，我们需要插入大量的 DOM 结构，但是到现在我们得到的仍然是一些虚拟的 fiber 节点。</p><p>所以，在最后一次单元工作 performUnitOfWork 中将会执行 <code>completeWork</code> ，在此之前，我们的单元工作是一步步向尾部的 fiber 节点移动。而在 <code>completeWork</code> 中，我们的工作将是自底向上，根据 fiber 生成真实的 dom 结构，并且在向上的过程中将这些结构拼接成一棵 dom 树。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">completeWork</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | null,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderExpirationTime: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 最新的 props</span></span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> WorkTag.HostComponent: &#123;</span><br><span class="line">      <span class="comment">// pop 该 fiber 对应的上下文</span></span><br><span class="line">      popHostContext(workInProgress)</span><br><span class="line">      <span class="comment">// 获取 stack 中的当前 dom</span></span><br><span class="line">      <span class="keyword">const</span> rootContainerInstance = getRootHostContainer()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 原生组件类型</span></span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果不是初次渲染了，可以尝试对已有的 dom 节点进行更新复用</span></span><br><span class="line">        updateHostComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          type <span class="keyword">as</span> string,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!newProps) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'如果没有newProps,是不合法的'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> currentHostContext = getHostContext()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建原生组件</span></span><br><span class="line">        <span class="keyword">let</span> instance = createInstance(</span><br><span class="line">          type <span class="keyword">as</span> string,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance,</span><br><span class="line">          currentHostContext,</span><br><span class="line">          workInProgress</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将之前所有已经生成的子 dom 元素装载到 instance 实例中</span></span><br><span class="line">			  <span class="comment">// 逐步拼接成一颗 dom 树</span></span><br><span class="line">        appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// fiber 的 stateNode 指向这个 dom 结构</span></span><br><span class="line">        workInProgress.stateNode = instance</span><br><span class="line"></span><br><span class="line">        <span class="comment">// feat: 这个函数真的藏得很隐蔽，我不知道这些人是怎么能注释都不提一句的呢→_→</span></span><br><span class="line">        <span class="comment">// finalizeInitialChildren 作用是将props中的属性挂载到真实的dom元素中去，结果作为一个判断条件被调用</span></span><br><span class="line">        <span class="comment">// 返回一个bool值，代表是否需要auto focus(input, textarea...)</span></span><br><span class="line">        <span class="keyword">if</span> (finalizeInitialChildren(instance, type <span class="keyword">as</span> string, newProps, rootContainerInstance, currentHostContext)) &#123;</span><br><span class="line">          markUpdate(workInProgress)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建完毕后，我们得到了形如下图，虚拟 dom 和 真实 dom，父元素和子元素之间的关系结构</p><p><img src="https://img12.360buyimg.com/ling/jfs/t1/128064/14/19510/42749/5fba15e8E1c00dca2/f1bd2f6b8ce53ca8.png" alt="https://img12.360buyimg.com/ling/jfs/t1/128064/14/19510/42749/5fba15e8E1c00dca2/f1bd2f6b8ce53ca8.png"></p><p>截止到当前，调和 reconcile 工作已经完成，我们已经进入了准备提交到文档 ready to commit 的状态。其实从进入 completeUnitOfWork 构建开始，后面的过程就已经和时间片，任务调度系统没有关系了，此时一切事件、交互、异步任务都将屏气凝神，聆听接下来 dom 的改变。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提交根实例(dom)到浏览器真实容器root中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRootImpl</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderPriorityLevel: ReactPriorityLevel</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">  <span class="comment">// 因为这次是整个组件树被挂载，所以根 fiber 节点将会作为 fiberRoot 的 finishedWork</span></span><br><span class="line">	<span class="keyword">const</span> finishedWork = root.finishedWork</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// effect 链表，即那些将要被插入的原生组件 fiber</span></span><br><span class="line">  <span class="keyword">let</span> firstEffect = finishedWork.firstEffect</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">let</span> nextEffect = firstEffect</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      commitMutationEffects(root, renderPriorityLevel)</span><br><span class="line">    &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 commitMutationEffects 函数之前其实对 effect 链表还进行了另外两次遍历，分别是一些生命周期的处理，例如 getSnapshotBeforeUpdate ，以及一些变量的准备。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正改写文档中dom的函数</span></span><br><span class="line"><span class="comment">// 提交fiber effect</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitMutationEffects</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  root: FiberRoot,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderPriorityLevel: number</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// @question 这个 while 语句似乎是多余的 = =</span></span><br><span class="line">  <span class="keyword">while</span> (nextEffect !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 当前fiber的tag</span></span><br><span class="line">    <span class="keyword">const</span> effectTag = nextEffect.effectTag</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下方的switch语句只处理 Placement,Deletion 和 Update</span></span><br><span class="line">    <span class="keyword">const</span> primaryEffectTag = effectTag &amp; (</span><br><span class="line">      EffectTag.Placement |</span><br><span class="line">      EffectTag.Update |</span><br><span class="line">      EffectTag.Deletion | </span><br><span class="line">      EffectTag.Hydrating</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">switch</span> (primaryEffectTag) &#123;</span><br><span class="line">      <span class="keyword">case</span> EffectTag.Placement: &#123;</span><br><span class="line">        <span class="comment">// 执行插入</span></span><br><span class="line">        commitPlacement(nextEffect)</span><br><span class="line">        <span class="comment">// effectTag 完成实名制后，要将对应的 effect 去除</span></span><br><span class="line">        nextEffect.effectTag &amp;= ~EffectTag.Placement</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> EffectTag.Update: &#123;</span><br><span class="line">        <span class="comment">// 更新现有的 dom 组件</span></span><br><span class="line">        <span class="keyword">const</span> current = nextEffect.alternate</span><br><span class="line">        commitWork(current, nextEffect)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextEffect = nextEffect.nextEffect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截至此刻，第一次渲染的内容已经在屏幕上出现。也就是说，真实 DOM 中的内容不再对应此时的 current fiber ，而是对应着我们操作的 workInProgress fiber ，即函数中的 finishedWork 变量。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 commit Mutation 阶段之后，workInProgress tree 已经是真实 Dom 对应的树了</span></span><br><span class="line"><span class="comment">// 所以之前的 tree 仍然是 componentWillUnmount 阶段的状态</span></span><br><span class="line"><span class="comment">// 所以此时， workInProgress 代替了 current 成为了新的 current</span></span><br><span class="line">root.current = finishedWork</span><br></pre></td></tr></table></figure><h1 id="一次点击事件" class="post-heading"><a href="#一次点击事件" class="headerlink" title="一次点击事件"></a>一次点击事件<a class="post-anchor" href="#一次点击事件" aria-hidden="true"></a></h1><p>如果你是一个经常使用 React 的打工人，就会发现 React 中的 event 是“阅后即焚的”。假设这样一段代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; MouseEvent &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TestPersist</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> handleClick = (</span><br><span class="line">		event: MouseEvent&lt;HTMLElement, globalThis.MouseEvent&gt;</span><br><span class="line">	) =&gt; &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'event'</span>, event))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		&lt;div onClick=&#123;handleClick&#125;&gt;O2&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">	)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>如果我们需要异步的获取这次点击事件在屏幕中的位置并且做出相应处理，那么在 setTimeout 中能否达到目的呢。</p><p>答案是否定的，因为 <strong>React</strong> 使用了 <strong>事件委托</strong> 机制，我们拿到的 event 对象并不是原生的 nativeEvent ，而是被 <strong>React</strong> 挟持处理过的合成事件 <strong>SyntheticEvent</strong> ，这一点从 ts 类型中也可以看出， 我们使用的 MouseEvent 是从 React 包中引入的而不是全局的默认事件类型。在 handleClick 函数同步执行完毕的一瞬间，这个 event 就已经在 React 事件池中被销毁了，我们可以跑这个组件康一康。</p><p><img src="https://img30.360buyimg.com/ling/jfs/t1/151336/9/7644/85935/5fba22f6E6d4a0a30/9d15606d04b891e6.png" alt="https://img30.360buyimg.com/ling/jfs/t1/151336/9/7644/85935/5fba22f6E6d4a0a30/9d15606d04b891e6.png"></p><p>当然 <strong>React</strong> 也提供了使用异步事件对象的解决方案，它提供了一个 persist 函数，可以让事件不再进入事件池。（在 React17 中为了解决某些 issue ，已经重写了合成事件机制，事件不再由 document 来代理，官网的说法是<a href="https://zh-hans.reactjs.org/docs/legacy-event-pooling.html" target="_blank" rel="noopener">合成事件</a>不再由事件池管理，也没有了 persist 函数）</p><p>那，为什么要用事件委托呢。还是回到那个经典的命题，渲染 2 个 div 当然横着写竖着写都没关系，如果是 1000 个组件 2000 个点击事件呢。事件委托的收益就是：</p><ol><li>简化了事件注册的流程，优化性能。</li><li>dom 元素不断在更新，你无法保证下一帧的 div 和上一帧中的 div 在内存中的地址是同一个。既然不是同一个，事件又要全部重新绑定，烦死了（指浏览器）。</li></ol><p>ok，言归正传。我们点击事件到底发生了什么呢。首先是在 React 的 render 函数执行之前，在 JS 脚本中就已经自动执行了事件的注入。</p><h2 id="事件注入" class="post-heading"><a href="#事件注入" class="headerlink" title="事件注入"></a>事件注入<a class="post-anchor" href="#事件注入" aria-hidden="true"></a></h2><p>事件注入的过程稍微有一点复杂，不光模块之间有顺序，数据也做了不少处理，这里不 po 太详细的代码。可能有人会问为啥不直接写死呢，浏览器的事件不也就那么亿点点。就像 Redux 不是专门为 <strong>React</strong> 服务的一样， <strong>React</strong> 也不是专门为浏览器服务的。文章开头也说了 React 只是一个 javascipt 库，它也可以服务 native 端、桌面端甚至各种终端。所以根据底层环境的不同动态的注入事件集也是非常合理的做法。</p><p>当然注入过程并不重要，我们需要知道的就是 <strong>React</strong> 安排了每种事件在 JSX 中的写法和原生事件的对应关系（例如 onClick 和 onclick ），以及事件的优先级。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ReactDOM环境 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// DOM 环境的事件 plugin</span></span><br><span class="line"><span class="keyword">const</span> DOMEventPluginOrder = [</span><br><span class="line">  <span class="string">'ResponderEventPlugin'</span>,</span><br><span class="line">  <span class="string">'SimpleEventPlugin'</span>,</span><br><span class="line">  <span class="string">'EnterLeaveEventPlugin'</span>,</span><br><span class="line">  <span class="string">'ChangeEventPlugin'</span>,</span><br><span class="line">  <span class="string">'SelectEventPlugin'</span>,</span><br><span class="line">  <span class="string">'BeforeInputEventPlugin'</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个文件被引入的时候自动执行 injectEventPluginOrder</span></span><br><span class="line"><span class="comment">// 确定 plugin 被注册的顺序，并不是真正引入</span></span><br><span class="line">EventPluginHub.injectEventPluginOrder(DOMEventPluginOrder)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的注入事件内容</span></span><br><span class="line">EventPluginHub.injectEventPluginByName(&#123;</span><br><span class="line">  SimpleEventPlugin: SimpleEventPlugin</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里以 <strong>SimpleEventPlugin</strong> 为例，点击事件等我们平时常用的事件都属于这个 plugin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 事件元组类型</span><br><span class="line">type EventTuple = [</span><br><span class="line">  DOMTopLevelEventType, // React 中的事件类型</span><br><span class="line">  string,               // 浏览器中的事件名称</span><br><span class="line">  EventPriority         // 事件优先级</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">const eventTuples: EventTuple[] = [</span><br><span class="line">  // 离散的事件</span><br><span class="line">  // 离散事件一般指的是在浏览器中连续两次触发间隔最少 33ms 的事件(没有依据，我猜的)</span><br><span class="line">  // 例如你以光速敲打键盘两次，这两个事件的实际触发时间戳仍然会有间隔</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_BLUR, &apos;blur&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_CANCEL, &apos;cancel&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_CHANGE, &apos;change&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_CLICK, &apos;click&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_CLOSE, &apos;close&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_CONTEXT_MENU, &apos;contextMenu&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_COPY, &apos;copy&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_CUT, &apos;cut&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_DOUBLE_CLICK, &apos;doubleClick&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_AUX_CLICK, &apos;auxClick&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_FOCUS, &apos;focus&apos;, DiscreteEvent ],</span><br><span class="line">  [ DOMTopLevelEventTypes.TOP_INPUT, &apos;input&apos;, DiscreteEvent ],</span><br><span class="line">	...</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么，这些事件的监听事件是如何被注册的呢。还记得在调和 Class 组件的时候会计算要向浏览器插入什么样的 dom 元素或是要如何更新 dom 元素。在这个过程中会通过 diffProperty 函数对元素的属性进行 diff 对比，其中通过 ListenTo 来添加监听函数</p><p>大家都知道，最终被绑定的监听事件一定是被 <strong>React</strong> 魔改过，然后绑定在 document 上的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function trapEventForPluginEventSystem (</span><br><span class="line">  element: Document | Element | Node,</span><br><span class="line">  topLevelType: DOMTopLevelEventType,</span><br><span class="line">  capture: boolean</span><br><span class="line">): void &#123;</span><br><span class="line">	// 生成一个 listener 监听函数</span><br><span class="line">  let listener</span><br><span class="line">  switch (getEventPriority(topLevelType)) &#123;</span><br><span class="line">    case DiscreteEvent: &#123;</span><br><span class="line">      listener = dispatchDiscreteEvent.bind(</span><br><span class="line">        null,</span><br><span class="line">        topLevelType,</span><br><span class="line">        EventSystemFlags.PLUGIN_EVENT_SYSTEM</span><br><span class="line">      )</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">		...</span><br><span class="line">    default: &#123;</span><br><span class="line">      listener = dispatchEvent.bind(</span><br><span class="line">        null,</span><br><span class="line">        topLevelType,</span><br><span class="line">        EventSystemFlags.PLUGIN_EVENT_SYSTEM</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // @todo 这里用一个getRawEventName转换了一下</span><br><span class="line">  // 这个函数就是 →_→</span><br><span class="line">  // const getRawEventName = a =&gt; a</span><br><span class="line">  // 虽然这个函数什么都没有做</span><br><span class="line">  // 但是它的名字语义化的说明了这一步</span><br><span class="line">  // 目的是得到浏览器环境下addEventListener第一个参数的合法名称</span><br><span class="line">  const rawEventName = topLevelType</span><br><span class="line">  // 将捕获事件listener挂载到根节点</span><br><span class="line">  // 这两个部分都是为了为了兼容 IE 封装过的 addEventListener</span><br><span class="line">  if (capture) &#123;</span><br><span class="line">    // 注册捕获事件</span><br><span class="line">    addEventCaptureListener(element, rawEventName, listener)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 注册冒泡事件</span><br><span class="line">    addEventBubbleListener(element, rawEventName, listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家应该都知道 addEventListener 的第三个参数是控制监听捕获过程 or 冒泡过程的吧</p><p><img src="https://img14.360buyimg.com/ling/jfs/t1/146083/13/15257/92531/5fba3093E68ec25bc/b189ae2c2eb7fe3e.jpg" alt="https://img14.360buyimg.com/ling/jfs/t1/146083/13/15257/92531/5fba3093E68ec25bc/b189ae2c2eb7fe3e.jpg"></p><p>ok，right now，鼠标点了下页面，页面调用了这个函数。开局就一个 nativeEvent 对象，这个函数要做的第一件事就是知道真正被点的那个组件是谁，其实看了一些源码就知道， <strong>React</strong> 但凡有什么事儿第一个步骤总是找到需要负责的那个 fiber 。</p><p>首先，通过 nativeEvent 获取目标 dom 元素也就是 dom.target</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const nativeEventTarget = getEventTarget(nativeEvent)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">export default function getEventTarget(nativeEvent) &#123;</span><br><span class="line">  // 兼容写法</span><br><span class="line">  let target = nativeEvent.target || nativeEvent.srcElement || window</span><br><span class="line"></span><br><span class="line">  // Normalize SVG</span><br><span class="line">  // @todo</span><br><span class="line"></span><br><span class="line">  return target.nodeType === HtmlNodeType.TEXT_NODE ? target.parentNode : target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么如何通过 dom 拿到这个 dom 对应的 fiber 呢，事实上， <strong>React</strong> 会给这个 dom 元素添加一个属性指向它对应的 fiber 。对于这个做法我是有疑问的，这样的映射关系也可以通过维护一个 <code>WeekMap</code> 对象来实现，操作一个 <code>WeakMap</code> 的性能或许会优于操作一个 DOM 的属性，且后者似乎不太优雅，如果你有更好的想法也欢迎在评论区指出。</p><p>每当 completeWork 中为 fiber 构造了新的 dom，都会给这个 dom 一个指针来指向它的 fiber</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 随机Key</span><br><span class="line">const randomKey = Math.random().toString(36).slice(2)</span><br><span class="line"></span><br><span class="line">// 随机Key对应的当前实例的Key</span><br><span class="line">const internalInstanceKey = &apos;__reactInternalInstance$&apos; + randomKey</span><br><span class="line">// Key 对应 render 之后的 props</span><br><span class="line">const internalEventHandlersKey = &apos;__reactEventHandlers$&apos; + randomKey</span><br><span class="line">// 对应实例</span><br><span class="line">const internalContianerInstanceKey = &apos;__reactContainer$&apos; + randomKey</span><br><span class="line"></span><br><span class="line">// 绑定操作</span><br><span class="line">export function precacheFiberNode (</span><br><span class="line">  hostInst: object,</span><br><span class="line">  node: Document | Element | Node</span><br><span class="line">): void &#123;</span><br><span class="line">  node[internalInstanceKey] = hostInst</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读取操作</span><br><span class="line">export function getClosestInstanceFromNode (targetNode) &#123;</span><br><span class="line">  let targetInst = targetNode[internalInstanceKey]</span><br><span class="line">  // 如果此时没有Key，直接返回null</span><br><span class="line">  if (targetInst) &#123;</span><br><span class="line">    return targetInst</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	// 省略了一部分代码</span><br><span class="line">	// 如果这个 dom 上面找不到 internalInstanceKey 这个属性</span><br><span class="line">  // 就会向上寻找父节点，直到找到一个拥有 internalInstanceKey 属性的 dom 元素</span><br><span class="line">  // 这也是为什么这个函数名要叫做 从 node 获取最近的 (fiber) 实例</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">  return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们已经拥有了原生事件的对象，以及触发了事件的 dom 以及对应的 fiber ，就可以从 fiber.memorizedProps 中取到我们绑定的 onClick 事件。这些信息已经足够生成一个 React 合成事件 ReactSyntheticEvent 的实例了。</p><p><strong>React</strong> 声明了一个全局变量 <strong>事件队列</strong> eventQueue ，这个队列用来存储某次更新中所有被触发的事件，我们需要让这个点击事件入队。然后触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 事件队列</span><br><span class="line">let eventQueue: ReactSyntheticEvent[] | ReactSyntheticEvent | null = null</span><br><span class="line"></span><br><span class="line">export function runEventsInBatch (</span><br><span class="line">  events: ReactSyntheticEvent[] | ReactSyntheticEvent | null</span><br><span class="line">) &#123;</span><br><span class="line">  if (events !== null) &#123;</span><br><span class="line">    // 存在 events 的话，加入事件队列</span><br><span class="line"></span><br><span class="line">    // react 自己写的合并数组函数 accumulateInto</span><br><span class="line">    // 或许是 ES3 时期写的吧</span><br><span class="line">    eventQueue = accumulateInto&lt;ReactSyntheticEvent&gt;(eventQueue, events)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	const processingEventQueue = eventQueue</span><br><span class="line"></span><br><span class="line">  // 执行完毕之后要清空队列</span><br><span class="line">  // 虽然已经这些 event 已经被释放了，但还是会被遍历</span><br><span class="line">  eventQueue = null</span><br><span class="line"></span><br><span class="line">  if (!processingEventQueue) return</span><br><span class="line"></span><br><span class="line">	// 将这些事件逐个触发</span><br><span class="line"></span><br><span class="line">  // forEachAccumulated 是 React 自己实现的 foreach</span><br><span class="line">  forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 触发一个事件并且立刻将事件释放到事件池中，除非执行了presistent</span><br><span class="line">const executeDispatchesAndRelease = function (event: ReactSyntheticEvent) &#123;</span><br><span class="line">  if (event) &#123;</span><br><span class="line">    // 按照次序依次触发和该事件类型绑定的所有 listener</span><br><span class="line">    executeDispatchesInOrder(event)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果没有执行 persist 持久化 , 立即销毁事件</span><br><span class="line">  if (!event.isPersistent()) &#123;</span><br><span class="line">    (event.constructor as any).release(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到合成事件的构造函数实例上挂载了一个函数 release ，用来释放事件。我们看一看 SyntheticEvent 的代码，可以发现这里使用了一个事件池的概念 eventPool 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(SyntheticEvent.prototype, &#123;</span><br><span class="line"></span><br><span class="line">	// 模拟原生的 preventDefault 函数</span><br><span class="line">  preventDefault: function() &#123;</span><br><span class="line">    this.defaultPrevented = true;</span><br><span class="line">    const event = this.nativeEvent;</span><br><span class="line">    if (!event) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (event.preventDefault) &#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      event.returnValue = false;</span><br><span class="line">    &#125;</span><br><span class="line">    this.isDefaultPrevented = functionThatReturnsTrue;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // 模拟原生的 stopPropagation</span><br><span class="line">  stopPropagation: function() &#123;</span><br><span class="line">    const event = this.nativeEvent;</span><br><span class="line">    if (!event) &#123;</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (event.stopPropagation) &#123;</span><br><span class="line">      event.stopPropagation();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      event.cancelBubble = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    this.isPropagationStopped = functionThatReturnsTrue;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 在每次事件循环之后，所有被 dispatch 过的合成事件都会被释放</span><br><span class="line">   * 这个函数能够允许一个引用使用事件不会被 GC 回收</span><br><span class="line">   */</span><br><span class="line">  persist: function() &#123;</span><br><span class="line">    this.isPersistent = functionThatReturnsTrue;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 这个 event 是否会被 GC 回收</span><br><span class="line">   */</span><br><span class="line">  isPersistent: functionThatReturnsFalse,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 销毁实例</span><br><span class="line">   * 就是将所有的字段都设置为 null</span><br><span class="line">   */</span><br><span class="line">  destructor: function() &#123;</span><br><span class="line">    const Interface = this.constructor.Interface;</span><br><span class="line">    for (const propName in Interface) &#123;</span><br><span class="line">      this[propName] = null;</span><br><span class="line">    &#125;</span><br><span class="line">    this.dispatchConfig = null;</span><br><span class="line">    this._targetInst = null;</span><br><span class="line">    this.nativeEvent = null;</span><br><span class="line">    this.isDefaultPrevented = functionThatReturnsFalse;</span><br><span class="line">    this.isPropagationStopped = functionThatReturnsFalse;</span><br><span class="line">    this._dispatchListeners = null;</span><br><span class="line">    this._dispatchInstances = null;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>React</strong> 在构造函数上直接添加了一个事件池属性，其实就是一个数组，这个数组将被全局共用。每当事件被释放的时候，如果线程池的长度还没有超过规定的大小（默认是 10 ），那么这个被销毁后的事件就会被放进事件池</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 为合成事件构造函数添加静态属性</span><br><span class="line">// 事件池为所有实例所共用</span><br><span class="line">function addEventPoolingTo (EventConstructor) &#123;</span><br><span class="line">  EventConstructor.eventPool = []</span><br><span class="line">  EventConstructor.getPooled = getPooledEvent</span><br><span class="line">  EventConstructor.release = releasePooledEvent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 将事件释放</span><br><span class="line">// 事件池有容量的话，放进事件池</span><br><span class="line">function releasePooledEvent (event) &#123;</span><br><span class="line">  const EventConstructor = this</span><br><span class="line">  event.destructor()</span><br><span class="line">  if (EventConstructor.eventPool.length &lt; EVENT_POOL_SIZE) &#123;</span><br><span class="line">    EventConstructor.eventPool.push(event)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道单例模式，就是对于一个类在全局最多只会有一个实例。而这种事件池的设计相当于是 n 例模式，每次事件触发完毕之后，实例都要还给构造函数放进事件池，后面的每次触发都将复用这些干净的实例，从而减少内存方面的开销。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 需要事件实例的时候直接从事件池中取出</span><br><span class="line">function getPooledEvent(dispatchConfig, targetInst, nativeEvent, nativeInst) &#123;</span><br><span class="line">  const EventConstructor = this</span><br><span class="line">  if (EventConstructor.eventPool.length) &#123;</span><br><span class="line">    // 从事件池中取出最后一个</span><br><span class="line">    const instance = EventConstructor.eventPool.pop()</span><br><span class="line">    EventConstructor.call(</span><br><span class="line">      instance,</span><br><span class="line">      dispatchConfig,</span><br><span class="line">      targetInst,</span><br><span class="line">      nativeEvent,</span><br><span class="line">      nativeInst</span><br><span class="line">    )</span><br><span class="line">    return instance</span><br><span class="line">  &#125;</span><br><span class="line">  return new EventConstructor (</span><br><span class="line">    dispatchConfig,</span><br><span class="line">    targetInst,</span><br><span class="line">    nativeEvent,</span><br><span class="line">    nativeInst</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在短时间内浏览器事件被频繁触发，那么将出现的现象是，之前事件池中的实例都被取出复用，而后续的合成事件对象就只能被老老实实重新创建，结束的时候通过放弃引用来被 V8 引擎的 GC 回收。</p><p>回到之前的事件触发，如果不特地将属性名写成 onClickCapture 的话，那么默认将被触发的就会是冒泡过程。这个过程也是 <strong>React</strong> 模拟的，就是通过 fiber 逐层向上触发的方式，捕获过程也是同理。</p><p>我们都知道正常的事件触发流程是：</p><ol><li>事件捕获</li><li>处于事件</li><li>事件冒泡</li></ol><p><strong>处于事件</strong> 阶段是一个 try-catch 语句，这样即使发生错误也会处于 <strong>React</strong> 的错误捕获机制当中。我们真正想要执行的函数实体就是在此被触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">export default function invodeGuardedCallbackImpl&lt;</span><br><span class="line">  A,</span><br><span class="line">  B,</span><br><span class="line">  C,</span><br><span class="line">  D,</span><br><span class="line">  E,</span><br><span class="line">  F,</span><br><span class="line">  Context</span><br><span class="line">&gt;(</span><br><span class="line">  name: string | null,</span><br><span class="line">  func: (a: A, b: B, c: C, d: D, e: E, f: F) =&gt; void,</span><br><span class="line">  context?: Context,</span><br><span class="line">  a?: A,</span><br><span class="line">  b?: B,</span><br><span class="line">  c?: C,</span><br><span class="line">  d?: D,</span><br><span class="line">  e?: E,</span><br><span class="line">  f?: F,</span><br><span class="line">): void &#123;</span><br><span class="line">  const funcArgs = Array.prototype.slice.call(arguments, 3)</span><br><span class="line">  try &#123;</span><br><span class="line">    func.apply(context, funcArgs)</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    this.onError(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类与函数" class="post-heading"><a href="#类与函数" class="headerlink" title="类与函数"></a>类与函数<a class="post-anchor" href="#类与函数" aria-hidden="true"></a></h1><p>当我们使用类组件或是函数组件的时候，最终目的都是为了得到一份 JSX 来描述我们的页面。那么其中就存在着一个问题—— <strong>React</strong> 是如何分辨函数组件和类组件的。</p><p>虽然在 ES6 中，我们可以轻易的看出 Class 和 函数的区别，但是别忘了，我们实际使用的往往是 babel 编译后的代码，而类就是函数和原型链构成的语法糖。可能大部分人最直接的想法就是，既然类组件继承了 React.Component ，那么应该可以直接使用类类型判断就就行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">App instanceof React.Component</span><br></pre></td></tr></table></figure><p>当然， <strong>React</strong> 采用的做法是在原型链上添加一个标识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Component.prototype.isReactComponent = &#123;&#125;</span><br></pre></td></tr></table></figure><p>源码中需要判断是否是类组件的时候，就可以直接读取函数的 isReactComponent 属性时，因为在函数（也是对象）自身找不到时，就会向上游原型链逐级查找，直到到达 Object.prototype 对象为止。</p><p><a href="https://github.com/facebook/react/pull/4663" target="_blank" rel="noopener">为什么 isReactComponent 是一个对象而不是布尔以及为什么不能用 instanceOf</a></p><h1 id="状态的更新" class="post-heading"><a href="#状态的更新" class="headerlink" title="状态的更新"></a>状态的更新<a class="post-anchor" href="#状态的更新" aria-hidden="true"></a></h1><p>之前我们已经看懂了 React 的事件委托机制，那么不如在一次点击事件中尝试修改组件的状态来更新我们的页面。</p><p>首先康康 setState 是如何工作的，我们知道 this.setState 是 React.Component 类中的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @description 更新组件state</span><br><span class="line"> * @param &#123; object | Function &#125; partialState 下个阶段的状态</span><br><span class="line"> * @param &#123; ?Function &#125; callback 更新完毕之后的回调</span><br><span class="line"> */</span><br><span class="line">Component.prototype.setState = function (partialState, callback) &#123;</span><br><span class="line">  if (!(</span><br><span class="line">    isObject(partialState) ||</span><br><span class="line">    isFunction(partialState) ||</span><br><span class="line">    isNull</span><br><span class="line">  )) &#123;</span><br><span class="line">    console.warn(&apos;setState的第一个参数应为对象、函数或null&apos;)</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  this.updater.enqueueSetState(this, partialState, callback, &apos;setState&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来核心步骤就是触发挂载在实例上的一个 updater 对象。默认的， updater 会是一个展位的空对象，虽然实现了 enqueueSetState 等方法，但是这些方法内部都是空的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 我们初始化这个默认的update，真正的updater会被renderer注入</span><br><span class="line">this.updater = updater || ReactNoopUpdateQueue</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">export const ReactNoopUpdateQueue = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * 检查组件是否已经挂载</span><br><span class="line">   */</span><br><span class="line">  isMounted: function (publishInstance) &#123;</span><br><span class="line">    // 初始化ing的组件就别挂载不挂载了</span><br><span class="line">    return false</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 强制更新</span><br><span class="line">   */</span><br><span class="line">  enqueueForceUpdate: function (publishInstance, callback, callerName) &#123;</span><br><span class="line">    console.warn(&apos;enqueueForceUpdate&apos;, publishInstance)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 直接替换整个state,通常用这个或者setState来更新状态</span><br><span class="line">   */</span><br><span class="line">  enqueueReplaceState: function (</span><br><span class="line">    publishInstance,</span><br><span class="line">    completeState,</span><br><span class="line">    callback,</span><br><span class="line">    callerName</span><br><span class="line">  ) &#123;</span><br><span class="line">    console.warn(&apos;enqueueReplaceState&apos;, publishInstance)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 修改部分state</span><br><span class="line">   */</span><br><span class="line">  enqueueSetState: function (</span><br><span class="line">    publishInstance,</span><br><span class="line">    partialState,</span><br><span class="line">    callback,</span><br><span class="line">    callerName</span><br><span class="line">  ) &#123;</span><br><span class="line">    console.warn(&apos;enqueueSetState&apos;, publishInstance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得我们在 render 的过程中，是通过执行 Component.render() 来获得一个类组件的实例，当 React 得到了这个实例之后，就会将实例的 updater 替换成真正的 classComponentUpdater ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function adoptClassInstance (</span><br><span class="line">  workInProgress: Fiber,</span><br><span class="line">  instance: any</span><br><span class="line">): void &#123;</span><br><span class="line">  instance.updater = classComponentUpdate</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚我们触发了这个对象中的 enqueueSetState 函数，那么可以看看实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">const classComponentUpdate = &#123;</span><br><span class="line">  isMounted,</span><br><span class="line">  /**</span><br><span class="line">   * 触发组件状态的更新</span><br><span class="line">   * @param inst ReactElement</span><br><span class="line">   * @param payload any</span><br><span class="line">   * @param callback 更新结束之后的回调</span><br><span class="line">   */</span><br><span class="line">  enqueueSetState(</span><br><span class="line">    inst: ReactElement,</span><br><span class="line">    payload: any,</span><br><span class="line">    callback?: Function</span><br><span class="line">  ) &#123;</span><br><span class="line">    // ReactElement -&gt; fiber</span><br><span class="line">    const fiber = getInstance(inst)</span><br><span class="line">    // 当前时间</span><br><span class="line">    const currentTime = requestCurrentTime()</span><br><span class="line">    // 获取当前 suspense config</span><br><span class="line">    const suspenseConfig = requestCurrentSuspenseConfig()</span><br><span class="line">    // 计算当前 fiber 节点的任务过期时间</span><br><span class="line">    const expirationTime = computeExpirationForFiber(</span><br><span class="line">      currentTime,</span><br><span class="line">      fiber,</span><br><span class="line">      suspenseConfig</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    // 创建一个 update 实例</span><br><span class="line">    const update = createUpdate(expirationTime, suspenseConfig)</span><br><span class="line">    update.payload = payload</span><br><span class="line">    // 将 update 装载到 fiber 的 queue 中</span><br><span class="line">    enqueueUpdate(fiber, update)</span><br><span class="line">    // 安排任务</span><br><span class="line">    ScheduleWork(fiber, expirationTime)</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，这个函数的作用就是获得类组件对应的 fiber ，更新它在任务调度器中的过期时间（领导给了新工作，自然要定新的 <strong>Deadline ）</strong>，然后就是创建一个新的 update 任务装载到 fiber 的任务队列中。最后通过 ScheduleWork （告诉任务调度器来任务了，赶紧干活） 要求从这个 fiber 开始调和，至于调和和更新的步骤我们在第一次渲染中已经有了大致的了解。</p><p>顺带提一提 Hooks 中的 useState 。网络上有挺多讲解 hook 实现的文章已经讲得很全面了，我们只需要搞清楚以下几点问题。</p><p>Q1. 函数组件不像类组件一样拥有实例，数据存储在哪里</p><p>A1. 任何以 ReactElement 为粒度的组件都需要围绕 fiber ，数据存储在 fiber.memorizedState 上</p><p>Q2. useState 的实现</p><p>A2. 如果你听过了 useState 那么你就应该听过 useReducer ，如果听过 reducer 就应该知道 redux。首先，useState 的本质就是 useReducer 的语法糖。我们都知道构建一个状态库需要一个 reducer ，useState 就是当 reducer 函数为 <code>a =&gt; a</code> 时的特殊情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function basicStateReducer&lt;S&gt;(state: S, action: BasicStateAction&lt;S&gt;): S &#123;</span><br><span class="line">  return typeof action === &apos;function&apos; ? action(state) : action</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function updateState&lt;S&gt;(</span><br><span class="line">  initialState: (() =&gt; S) | S</span><br><span class="line">): [ S, Dispatch&lt;BasicStateAction&lt;S&gt;&gt; ] &#123;</span><br><span class="line">  return updateReducer&lt;S, (() =&gt; S) | S, any&gt;(basicStateReducer, initialState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Q3. 为什么 Hooks 的顺序和个数不允许改变</p><p>A3. 每次执行 Hooks 函数需要取出上一次渲染时数据的最终状态，因为结构是链表而不是一个 Map，所以这些最终状态也会是有序的，所以如果个数和次序改变会导致数据的错乱。</p><h2 id="时间调度机制" class="post-heading"><a href="#时间调度机制" class="headerlink" title="时间调度机制"></a>时间调度机制<a class="post-anchor" href="#时间调度机制" aria-hidden="true"></a></h2><p>虽然今年过期时间 expirationTime 机制已经被淘汰了，但是不管是航道模型还是过期时间，本质上都是任务优先级的不同体现形式。</p><p>在探究运行机制之前我们需要知道一个问题就是，为什么时间片的性能会优于同步计算的性能。此处借用司徒正美老师<a href="https://zhuanlan.zhihu.com/p/37095662" target="_blank" rel="noopener">文章</a>中的例子。</p><p>实验1，通过 for 循环一次性向 document 中插入1000 个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function randomHexColor()&#123;</span><br><span class="line">    return &quot;#&quot; + (&quot;0000&quot;+ (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).substr(-6);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">    var k = 0;</span><br><span class="line">    var root = document.getElementById(&quot;root&quot;);</span><br><span class="line">    for(var i = 0; i &lt; 10000; i++)&#123;</span><br><span class="line">        k += new Date - 0 ;</span><br><span class="line">        var el = document.createElement(&quot;div&quot;);</span><br><span class="line">        el.innerHTML = k;</span><br><span class="line">        root.appendChild(el);</span><br><span class="line">        el.style.cssText =  background:$&#123;randomHexColor()&#125;;height:40px ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>实验2，进行 10 次 setTimeout 分批次操作，每次插入 100 个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function randomHexColor() &#123;</span><br><span class="line">    return &quot;#&quot; + (&quot;0000&quot; + (Math.random() * 0x1000000 &lt;&lt; 0).toString(16)).substr(-6);</span><br><span class="line">&#125;</span><br><span class="line">var root = document.getElementById(&quot;root&quot;);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    function loop(n) &#123;</span><br><span class="line">        var k = 0;</span><br><span class="line">        console.log(n);</span><br><span class="line">        for (var i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">            k += new Date - 0;</span><br><span class="line">            var el = document.createElement(&quot;div&quot;);</span><br><span class="line">            el.innerHTML = k;</span><br><span class="line">            root.appendChild(el);</span><br><span class="line">            el.style.cssText =  background:$&#123;randomHexColor()&#125;;height:40px ;</span><br><span class="line">        &#125;</span><br><span class="line">        if (n) &#123;</span><br><span class="line">            setTimeout(function () &#123;</span><br><span class="line">                loop(n - 1);</span><br><span class="line">            &#125;, 40);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    loop(100);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure><p>相同的结果，第一个实验花费了 1000 ms，而第二个实验仅仅花费了 31.5 ms。</p><p>这和 <strong>V8</strong> 引擎的底层原理有关，我们都知道浏览器是单线程，一次性需要做到 GUI 描绘，事件处理，JS 执行等多个操作时，V8 引擎会优先对代码进行执行，而不会对执行速度进行优化。如果我们稍微给浏览器一些时间，浏览器就能够进行 JIT ，也叫热代码优化。</p><p>简单来说， JS 是一种解释型语言，每次执行都需要被编译成字节码才能被运行。但是如果某个函数被多次执行，且参数类型和参数个数始终保持不变。那么这段代码会被识别为 <strong>热代码</strong> ，遵循着“万物皆可空间换时间”的原则，这段代码的字节码会被缓存，下次再次运行的时候就会直接被运行而不需要进行耗时的解释操作。也就是 <strong>解释器 + 编译器</strong> 的模式。</p><p>做个比喻来说，我们工作不能一直蛮干，必须要给自己一些时间进行反思和总结，否则工作速度和效率始终是线性的，人也不会有进步。</p><p>还记得在 WorkLoop 函数中，每次处理完一个 fiber 都会跳出循环执行一次 shouldYield 函数进行判断，是否应该将执行权交还给浏览器处理用户时间或是渲染。看看这个 shouldYield 函数的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 当前是否应该阻塞 react 的工作</span><br><span class="line">function shouldYield (): boolean &#123;</span><br><span class="line">  // 获取当前的时间点</span><br><span class="line">  const currentTime = getCurrentTime()</span><br><span class="line"></span><br><span class="line">  // 检查任务队列中是否有任务需要执行</span><br><span class="line">  advanceTimers(currentTime)</span><br><span class="line"></span><br><span class="line">  // 取出任务队列中任务优先级最高的任务</span><br><span class="line">  const firstTask = peek(taskQueue)</span><br><span class="line"></span><br><span class="line">  // 以下两种情况需要yield</span><br><span class="line">  // 1. 当前任务队列中存在任务，且第一个任务的开始时间还没到，且过期时间小于当前任务</span><br><span class="line">  // 2. 处于固定的浏览器渲染时间区间</span><br><span class="line">  return (</span><br><span class="line">    (</span><br><span class="line">      currentTask !== null &amp;&amp;</span><br><span class="line">      firstTask !== null &amp;&amp;</span><br><span class="line">      (firstTask as any).startTime &lt;= currentTime &amp;&amp;</span><br><span class="line">      (firstTask as any).expirationTime &lt; currentTask.expirationTime</span><br><span class="line">    )</span><br><span class="line">    // 当前处于时间片的阻塞区间</span><br><span class="line">    || shouldYieldToHost()</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>决定一个任务当前是否应该被执行有两个因素。</p><ol><li>这个任务是否非执行不可，正所谓一切的不论是不是先问为什么都是耍流氓。如果到期时间还没到，为什么不先把线程空出来留给可能的高优先级任务呢。</li><li>如果多个任务都非执行不可，那么任务的优先级是否是当前队列中最高的。</li></ol><p>如果一个任务的过期时间已经到了必须执行，那么这个任务就应该处于 <strong>待执行队列</strong> taskQueue 中。相反这个任务的过期时间还没到，就可以先放在 <strong>延迟列表</strong> 中。每一帧结束的时候都会执行 advanceTimer 函数，将一些延迟列表中到期的任务取出，插入待执行队列。</p><p>可能是出于最佳实践考虑，待执行队列是一个小根堆结构，而延迟队列是一个有序链表。</p><p>回想一下 React 的任务调度要求，当一个新的优先级更高的任务产生，需要能够打断之前的工作并插队。也就是说，React 需要维持一个始终有序的数组数据结构。因此，React 自实现了一个小根堆，但是这个小根堆无需像堆排序的结果一样整体有序，只需要保证每次进行 push 和 pop 操作之后，优先级最高的任务能够到达堆顶。</p><p>所以 shouldYield 返回 true 的一个关键条件就是，当前 taskQueue 堆中的堆顶任务的过期时间已经到了，那么就应该暂停工作交出线程使用权。</p><p>那么待执行的任务是如何被执行的呢。这里我们需要先了解 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel" target="_blank" rel="noopener">MessageChannel</a> 的概念。Message</p><p>Channel 的实例会拥有两个端口，其中第一个端口为发送信息的端口，第二个端口为接收信息的端口。当接收到信息就可以执行指定的回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const channel = new MessageChannel()</span><br><span class="line">// 发送端</span><br><span class="line">const port = channel.port2</span><br><span class="line">// 接收端</span><br><span class="line">channel.port1.onmessage = performWorkUntilDeadline // 在一定时间内尽可能的处理任务</span><br></pre></td></tr></table></figure><p>每当待执行任务队列中有任务的时候，就会通过 Channel 的发送端发送一个空的 message ，当接收端异步地接收到这个信号的时候，就会在一个时间片内尽可能地执行任务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// 记录任一时间片的结束时刻</span><br><span class="line">let deadline = 0</span><br><span class="line"></span><br><span class="line">// 单位时间切片长度</span><br><span class="line">let yieldInterval = 5</span><br><span class="line"></span><br><span class="line">// 执行任务直到用尽当前时间片空闲时间</span><br><span class="line">function performWorkUntilDeadline () &#123;</span><br><span class="line">  if (scheduledHostCallback !== null) &#123;</span><br><span class="line">    // 如果有计划任务，那么需要执行</span><br><span class="line">    </span><br><span class="line">    // 当前时间</span><br><span class="line">    const currentTime = getCurrentTime()</span><br><span class="line"></span><br><span class="line">    // 在每个时间片之后阻塞(5ms)</span><br><span class="line">    // deadline 为这一次时间片的结束时间</span><br><span class="line">    deadline = currentTime + yieldInterval</span><br><span class="line"></span><br><span class="line">    // 既然能执行这个函数，就代表着还有时间剩余</span><br><span class="line">    const hasTimeRemaining = true</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">      // 将当前阻塞的任务计划执行</span><br><span class="line">      const hasMoreWork = scheduledHostCallback(</span><br><span class="line">        hasTimeRemaining,</span><br><span class="line">        currentTime</span><br><span class="line">      )</span><br><span class="line">      </span><br><span class="line">      if (!hasMoreWork) &#123;</span><br><span class="line">        // 如果没有任务了, 清空数据</span><br><span class="line">        isMessageLoopRunning = false</span><br><span class="line">        scheduledHostCallback = null</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 如果还有任务，在当前时间片的结尾发送一个 message event</span><br><span class="line">				// 接收端接收到的时候就将进入下一个时间片</span><br><span class="line">        port.postMessage(null)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">      port.postMessage(null)</span><br><span class="line">      throw(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 压根没有任务，不执行</span><br><span class="line">    isMessageLoopRunning = false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在之前说过，阻塞 WorkLoop 的条件有两个，第一个是任务队列的第一个任务还没到时间，第二个条件就是 shouldYieldToHost 返回 true，也就是处于时间片期间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 此时是否是【时间片阻塞】区间</span><br><span class="line">export function shouldYieldToHost () &#123;</span><br><span class="line">  return getCurrentTime() &gt;= deadline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，时间调度机制其实就是 fiber 遍历任务 WorkLoop 和调度器中的任务队列争夺线程使用权的过程。不过区别是前者完全是同步的过程，只会在每个 while 的间隙去询问 <strong>调度器</strong> ：我是否可以继续执行下去。而在调度器拿到线程使用权的每个时间片中，都会尽可能的处理任务队列中的任务。</p><p>传统武术讲究点到为止，以上内容，就是这次 <strong>React</strong> 原理的全部。在文章中我并没有放出大量的代码，只是放出了一些片段用来佐证我对于源码的一些看法和观点，文中的流程只是一个循序思考的过程，如果需要查看更多细节还是应该从源码入手。</p><p>当然文中的很多观点带有主观色彩，并不一定就正确，同时我也不认为网络上的其他文章的说法就和 React 被设计时的初衷完全一致，甚至 React 源码中的很多写法也未必完美。不管阅读什么代码，我们都不要神话它，而是应该辩证的去看待它。总的来说，功过91开。</p><p>前端世界并不需要第二个 <strong>React</strong> ，我们学习的意义并不是为了证明我们对这个框架有多么了解。而是通过窥探这些顶级工程师的实现思路，去完善我们自己的逻辑体系，从而成为一个更加严谨的人。</p><div class="post-tags" style="display:none"><a href="/tags/React/">React</a> <a href="/tags/前端/">前端</a> <a href="/tags/技术/">技术</a></div><div class="post-categories" style="display:none"><a href="/cates/经验分享/">经验分享</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2020/11/12/react-indoor/">https://aotu.io/notes/2020/11/12/react-indoor/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2021-02-02T07:48:05.254Z">上次更新：2021-02-02 15:48:05</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2020/11/12/mongo-replica-set/" title="MongoDB 副本集之入门篇">MongoDB 副本集之入门篇 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2020/11/05/easeJs-center-setting/" title="EaseJs 中 regX / regY 的用法"><i class="fa fa-chevron-left"></i> EaseJs 中 regX / regY 的用法</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"bm90ZXMvMjAyMC8xMS8xMi9yZWFjdC1pbmRvb3Iv",owner:"o2team",repo:"o2team.github.io",title:"React 入门儿",body:"https://aotu.io/notes/2020/11/12/react-indoor/index.html\n\n无",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["mamboer"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdrd.jd.com" target="_blank" title="京东零售设计服务平台">京东零售设计服务平台</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2021. All Rights Reserved.</p><p><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>