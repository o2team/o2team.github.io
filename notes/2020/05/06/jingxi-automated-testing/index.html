<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>京喜前端自动化测试之路 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="测试,自动化,H5,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2020/05/06/jingxi-automated-testing/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 原来的容灾演习过程：小程序（通信方式改成 Https ）和 H5 通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降"><meta name="keywords" content="H5,自动化,测试"><meta property="og:type" content="article"><meta property="og:title" content="京喜前端自动化测试之路"><meta property="og:url" content="https://aotu.io/notes/2020/05/06/jingxi-automated-testing/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 原来的容灾演习过程：小程序（通信方式改成 Https ）和 H5 通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://img30.360buyimg.com/ling/jfs/t1/115424/38/1808/102160/5e9c5c8cE6d75a082/39c70c3c762fc1a2.png"><meta property="og:image" content="https://img13.360buyimg.com/ling/jfs/t1/85343/7/19603/109253/5e9e9193Ed032c092/9e1c3e63f275d637.png"><meta property="og:image" content="https://img13.360buyimg.com/ling/jfs/t1/86605/32/10488/1118934/5e1b0570E6d8d09f1/ef1885490c8fd917.png"><meta property="og:image" content="https://storage.360buyimg.com/ling-gif/自动化2_1587448409255_628.gif"><meta property="og:updated_time" content="2021-02-02T07:48:05.250Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="京喜前端自动化测试之路"><meta name="twitter:description" content="前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 原来的容灾演习过程：小程序（通信方式改成 Https ）和 H5 通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降"><meta name="twitter:image" content="https://img30.360buyimg.com/ling/jfs/t1/115424/38/1808/102160/5e9c5c8cE6d75a082/39c70c3c762fc1a2.png"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="http://img14.360buyimg.com/ling/jfs/t1/99147/32/19468/217793/5e9ec536Ee8206080/f5c84d32902e42d5.jpg" alt="京喜前端自动化测试之路"></div><header class="post-hd"><h1 class="post-tit">京喜前端自动化测试之路</h1><div class="post-meta">by <a target="_blank" href="https://github.com/zhangxiang910" class="post-author">阿翔</a> on <span>2020-05-06</span></div><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><h2 id="前言" class="post-heading"><a href="#前言" class="headerlink" title="前言"></a>前言<a class="post-anchor" href="#前言" aria-hidden="true"></a></h2><p><strong>京喜</strong>（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 原来的容灾演习过程：小程序（通信方式改成 Https ）和 H5 通过 Whistle 对接口返回进行修改来模拟异常情况，验证各页面各模块的降级处理符合预期。容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景模拟异常导致演习效率很低，因此想通过开发自动化测试工具来提升研发效率，让容灾演习工作随时可以轻松开展。京喜 H5 和小程序场景差异比较大，因此自动化测试之路分 H5 和小程序两部分进行，以 H5 作为一个开篇。</p><p>综上所述，我们希望京喜 H5 自动化测试工具可以提供以下功能：</p><ol><li>访问目标页面，对页面进行截图；</li><li>设置 UA（模拟不同渠道：微信、手Q、其它浏览器等）；</li><li>模拟用户点击、滑动页面操作；</li><li>网络拦截、模拟异常情况（接口响应码 500、接口返回数据异常）；</li><li>操作缓存数据（模拟有无缓存的场景等）。</li></ol><h2 id="技术选型" class="post-heading"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型<a class="post-anchor" href="#技术选型" aria-hidden="true"></a></h2><p>提到 Web 的自动化测试，很多人熟悉的是 Selenium 2.0（Selenium WebDriver）， 支持多平台、多语言、多款浏览器（通过各种浏览器的驱动来驱动浏览器），提供了功能丰富的API接口。而随着前端技术的发展，Selenium 2.0 逐渐呈现出环境安装复杂、API 调用不友好、性能不高等缺点。新一代的自动化测试工具 —— Puppeteer ，相较于 Selenium WebDriver 环境安装更简单、性能更好、效率更高、在浏览器执行 Javascript 的 API 更简单，它还提供了网络拦截等功能。</p><blockquote><p><a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/" target="_blank" rel="noopener">Puppeteer</a> 是一个 Node 库，它提供了一套高阶 API ，通过 Devtools 协议控制 <code>Chromium</code> 或 <code>Chrome</code> 浏览器。<code>Puppeteer</code> 默认以 <code>Headless</code> 模式运行，但是可以通过修改配置文件运行“有头”模式。</p></blockquote><p>官方描述的功能：</p><ul><li>生成页面 PDF；</li><li>抓取 SPA（单页应用）并生成预渲染内容（即“ SSR ”，服务器端渲染）；</li><li>自动提交表单，进行 UI 测试，键盘输入等；</li><li>创建一个时时更新的自动化测试环境，使用 JavaScript 和最新的浏览器功能直接在最新版本的 Chrome 中执行测试；</li><li>捕获网站的 Timeline Trace，用来帮助分析性能问题；</li><li>测试浏览器扩展。</li></ul><p>Puppeteer 提供了一种启动 Chromium 实例的方法。 当 Puppeteer 连接到一个 Chromium 实例的时候会通过 puppeteer.launch 或 puppeteer.connect 创建一个 Browser 对象，在通过 Browser 创建一个 Page 实例，导航到一个 Url ，然后保存截图。一个 Browser 实例可以有多个 Page 实例。 下面就是使用 Puppeteer 进行自动化的一个典型示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const puppeteer = require(<span class="string">'puppeteer'</span>);</span><br><span class="line">puppeteer.launch().then(async browser =&gt; &#123;</span><br><span class="line">  const<span class="built_in"> page </span>= await browser.newPage();</span><br><span class="line">  await page.goto(<span class="string">'https://example.com'</span>);</span><br><span class="line">  await page.screenshot(&#123;path: <span class="string">'screenshot.png'</span>&#125;);</span><br><span class="line">  await browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>综上所述，我们选择基于 Puppeteer 来开发京喜首页容灾演习的自动化测试工具，通过 Puppeteer 提供的一系列 API ，实现访问目标页面、模拟异常场景、生成截图的过程自动化。最后再通过人工比对截图，判断页面降级处理是否符合预期、用户体验是否友好。</p><h2 id="实现方案" class="post-heading"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案<a class="post-anchor" href="#实现方案" aria-hidden="true"></a></h2><p>我们将容灾演习过程分为自动化流程和人工操作两部分。</p><p><strong>自动化流程：</strong></p><ol><li>模拟用户访问页面操作；</li><li>拦截网络请求，修改接口返回数据，模拟异常场景（接口返回 500、异常数据等）；</li><li>生成截图。</li></ol><p><strong>人工操作：</strong></p><p>自动化脚本执行完毕后，人工比对各个场景的截图，判断是否符合预期。</p><p><strong>方案流程图：</strong><br><img src="https://img30.360buyimg.com/ling/jfs/t1/115424/38/1808/102160/5e9c5c8cE6d75a082/39c70c3c762fc1a2.png" alt="方案流程图"></p><h2 id="开发实录" class="post-heading"><a href="#开发实录" class="headerlink" title="开发实录"></a>开发实录<a class="post-anchor" href="#开发实录" aria-hidden="true"></a></h2><h3 id="安装-Puppeteer-，你可能会遇到的那些事" class="post-heading"><a href="#安装-Puppeteer-，你可能会遇到的那些事" class="headerlink" title="安装 Puppeteer ，你可能会遇到的那些事"></a>安装 Puppeteer ，你可能会遇到的那些事<a class="post-anchor" href="#安装-Puppeteer-，你可能会遇到的那些事" aria-hidden="true"></a></h3><p>通过 npm init 初始化项目后， 就可以安装 Puppeteer 依赖了：</p><p><code>npm i puppeteer</code> ：在安装时自动下载最新版本 Chromium。</p><p>或者</p><p><del><code>npm i puppeteer-core</code> ：在安装时不会自动下载 Chromium。</del>（不能生成截图）</p><p>另外，在安装过程中可能会因为下载 Chromium 导致报错，官网建议是先通过 <code>npm i --save puppeteer --ignore-scripts</code> 阻止下载 Chromium， 然后再手动下载 <a href="https://download-chromium.appspot.com/" target="_blank" rel="noopener">Chromium</a> 。</p><p>手动下载后，需要配置指定路径，修改 index.js 文件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        <span class="comment">// 运行 Chromium 或 Chrome 可执行文件的路径（相对路径）</span></span><br><span class="line">        executablePath: <span class="string">'./chrome-mac/Chromium.app/Contents/MacOS/Chromium'</span>, </span><br><span class="line">        headless: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">      <span class="keyword">await</span> page.goto(<span class="string">'https://example.com'</span>);</span><br><span class="line">      <span class="keyword">await</span> page.screenshot(&#123;path: <span class="string">'screenshot.png'</span>&#125;);</span><br><span class="line">      browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="快速创建测试用例" class="post-heading"><a href="#快速创建测试用例" class="headerlink" title="快速创建测试用例"></a>快速创建测试用例<a class="post-anchor" href="#快速创建测试用例" aria-hidden="true"></a></h3><p>为了提高测试脚本的可维护性、扩展性，我们将测试用例的信息都配置到 JSON 文件中，这样编写测试脚本的时候，我们只需关注测试流程的实现。</p><p>测试用例 JSON 数据配置包括<code>公用数据（global）</code>和<code>私有数据</code>：</p><p><code>公用数据（global）</code>：各测试用例都需要用到的数据，如：模拟访问的目标页面地址、名字、描述、设备类型等。</p><p><code>私有数据</code>： 各测试用例特定的数据，如测试模块信息、API 地址、测试场景、预期结果、截图名字等数据。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"global"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"https://wqs.jd.com/xxx/index.shtml"</span>,</span><br><span class="line">    <span class="string">"pageName"</span>: <span class="string">"index"</span>,</span><br><span class="line">    <span class="string">"pageDesc"</span>: <span class="string">"首页"</span>,</span><br><span class="line">    <span class="string">"device"</span>: <span class="string">"iPhone 7"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"homePageApi"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"home_page_api"</span>,</span><br><span class="line">    <span class="string">"moduleDesc"</span>: <span class="string">"首页主接口"</span>,</span><br><span class="line">    <span class="string">"api"</span>: <span class="string">"https://wqcoss.jd.com/xxx"</span>,</span><br><span class="line">    <span class="string">"operation"</span>: <span class="string">"模拟响应码 500"</span>,</span><br><span class="line">    <span class="string">"expectRules"</span>: [</span><br><span class="line">      <span class="string">"1. 显示异常信息、刷新按钮"</span>,</span><br><span class="line">      <span class="string">"2. 点击刷新按钮，显示异常信息"</span>,</span><br><span class="line">      <span class="string">"3. 恢复网络，点击刷新按钮，显示正常数据"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"screenshot"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"normal"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"正常场景"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_cache"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"有缓存-返回500"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_no_cache"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"无缓存-返回500"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_no_cache_reload"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"无缓存-返回500-点击刷新按钮"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_no_cache_recover"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"无缓存-返回500-恢复网络"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试脚本" class="post-heading"><a href="#编写测试脚本" class="headerlink" title="编写测试脚本"></a>编写测试脚本<a class="post-anchor" href="#编写测试脚本" aria-hidden="true"></a></h3><p>我们以京喜首页主接口的测试用例为例子，通过模接口返回 500 响应码的异常场景，验证主接口的异常处理机制是否完善、用户体验是否友好。</p><p><strong>预期效果：</strong></p><ul><li>有缓存情况下，显示缓存数据</li><li>无缓存情况下显示异常信息、刷新按钮</li><li>点击刷新按钮，显示异常信息</li><li>恢复网络，点击刷新按钮，显示正常数据</li></ul><p><strong>测试流程：</strong></p><p><img src="https://img13.360buyimg.com/ling/jfs/t1/85343/7/19603/109253/5e9e9193Ed032c092/9e1c3e63f275d637.png" alt="方案流程图"></p><p><strong>场景实现：</strong></p><p>根据测试流程以及配置的测试用例信息，编写测试脚本，实现测试用例场景:</p><ol><li>访问页面</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.<span class="keyword">goto</span>(url)</span><br></pre></td></tr></table></figure><ol start="2"><li>生成截图</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">await</span> <span class="selector-tag">page</span><span class="selector-class">.screenshot</span>(&#123;</span><br><span class="line">     <span class="attribute">path</span>: <span class="string">'./screenshot/index_home_page_500.png'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>拦截接口请求</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">async</span> <span class="title">test</span> (<span class="params"></span>)</span> =&gt; &#123;</span><br><span class="line">  ... <span class="comment">// 创建 Page 实例,访问首页</span></span><br><span class="line">  <span class="keyword">await</span> page.setRequestInterception(<span class="literal">true</span>) <span class="comment">// 设置拦截请求</span></span><br><span class="line">  page.<span class="keyword">on</span>(<span class="string">"request"</span>, interceptionEvent)   <span class="comment">// 监听请求事件，当请求发起后页面会触发这个事件</span></span><br><span class="line">  ... <span class="comment">// 刷新页面，触发请求拦截，生成测试场景截图</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若测试用例需要拦截不同的请求，或是模拟多种场景，则需要设置多个请求监听事件。且一个事件执行结束后，必须要移除事件监听，才能继续下一个事件监听。</p><p>添加事件监听：<code>page.on(&quot;request&quot;, eventFunction)</code></p><p>移除事件监听：<code>page.off(&quot;request&quot;, eventFunction)</code></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置拦截请求</span></span><br><span class="line"><span class="keyword">await</span> page.setRequestInterception(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">const</span> iconInterception1 = requestInterception(api, <span class="string">"body"</span>)</span><br><span class="line"><span class="comment">// 添加事件 1 监听</span></span><br><span class="line">page.<span class="keyword">on</span>(<span class="string">"request"</span>, iconInterception1)</span><br><span class="line"><span class="keyword">await</span> page.<span class="keyword">goto</span>(url)</span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">  path: <span class="string">'./screenshot/1.png'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 移除事件 1 监听 </span></span><br><span class="line">page.off(<span class="string">"request"</span>, iconInterception1)</span><br><span class="line"><span class="keyword">const</span> iconInterception2 = requestInterception(api, <span class="string">"body"</span>, )</span><br><span class="line"><span class="comment">// 添加事件 2 监听</span></span><br><span class="line">page.<span class="keyword">on</span>(<span class="string">"request"</span>, iconInterception2)</span><br><span class="line"><span class="keyword">await</span> page.<span class="keyword">goto</span>(url)</span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">  path: <span class="string">'./screenshot/2.png'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 移除事件 2 监听</span></span><br><span class="line">page.off(<span class="string">"request"</span>, iconInterception2)</span><br></pre></td></tr></table></figure><ol start="4"><li>模拟异常数据场景，生成 mock 数据。</li></ol><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestInterception</span> <span class="params">(api, setProps, setValue)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mockData</span><br><span class="line">  <span class="keyword">switch</span> (setProps) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"status"</span>:      <span class="comment">// 修改返回状态码</span></span><br><span class="line">      mockData = &#123;</span><br><span class="line">        status: setValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"contentType"</span>: <span class="comment">// 修改返回内容类型</span></span><br><span class="line">      mockData = &#123;</span><br><span class="line">        contentType: setValue</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"body"</span>:        <span class="comment">// 修改返回数据</span></span><br><span class="line">      mockData = &#123;</span><br><span class="line">        contentType: getMockResponse(setValue)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> async req =&gt; &#123;</span><br><span class="line">   <span class="comment">// 如果是需要拦截的 API，则通过 req.respond(mockData) 修改返回数据，否则 continue 继续请求别的</span></span><br><span class="line">    <span class="keyword">if</span> (req.url().includes(api)) &#123; <span class="comment">// 拦截 API</span></span><br><span class="line">      req.respond(mockData) <span class="comment">// 修改返回数据</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>  <span class="comment">// 处理完了某个请求必须退出，不再执行 continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    req.<span class="keyword">continue</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟接口返回 500：<br></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">int</span>erception500 = requestInterception(api, <span class="string">'status'</span>, <span class="number">500</span>)</span><br><span class="line">page.on(<span class="string">"request"</span>, <span class="built_in">int</span>erception500) <span class="comment">// 当请求发起后页面会触发这个事件</span></span><br></pre></td></tr></table></figure><p></p><p>模拟异常数据：<br></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const iconInterception = requestInterception(api, <span class="string">"body"</span>, &#123; </span><br><span class="line">    <span class="string">"data"</span>: &#123;</span><br><span class="line">      <span class="string">"modules"</span>: [&#123;</span><br><span class="line">         <span class="string">"tpl"</span>: <span class="string">"3000"</span>,</span><br><span class="line">         <span class="string">"content"</span>: []</span><br><span class="line">       &#125;]</span><br><span class="line">     &#125;</span><br><span class="line">&#125;)</span><br><span class="line">page.<span class="keyword">on</span><span class="params">(<span class="string">"request"</span>, iconInterception)</span></span><br></pre></td></tr></table></figure><p></p><p>生成 mock 数据有两种实现方案，可依据实际情况而定：</p><ul><li style="list-style:none"><input type="checkbox"> 直接通过修改接口真实返回的数据生成 mock 数据，需要先获取接口实时返回数据</li><li style="list-style:none"><input type="checkbox" checked> 本地存储一份完整的接口数据，通过修改本地存储数据的方式生成 mock 数据（本文所述案例均基于此方案实现）</li></ul><p>若选择第一种方案，则需先拦截接口请求，通过 req.response() 获取接口实时返回数据，根据测试场景修改实时返回数据作为 mock 数据。</p><p>由于京喜 H5 页面接口返回是 JSONP 格式的数据，所以在模拟返回数据的时候，必须先截取 JSONP 的 callback 信息，与模拟数据拼接后再返回；</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestInterception</span> <span class="params">(api, setProps, setValue)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> mockData</span><br><span class="line">   <span class="keyword">switch</span> (setProps) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">"status"</span>:</span><br><span class="line">       mockData = &#123;</span><br><span class="line">         status: setValue</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">case</span> <span class="string">"contentType"</span>:</span><br><span class="line">       mockData = &#123;</span><br><span class="line">         contentType: setValue</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">break</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> async req =&gt; &#123;</span><br><span class="line">     <span class="keyword">if</span> (req.url().includes(api)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (setProps === <span class="string">"body"</span>) &#123;</span><br><span class="line">         <span class="keyword">const</span> callback = getUrlParam(<span class="string">"callback"</span>, req.url())  <span class="comment">// 获取 callback 信息</span></span><br><span class="line">         <span class="keyword">const</span> localData = getLocalMockResponse(api)  <span class="comment">// 匹配 API ，获取本地存储数据</span></span><br><span class="line">         mockData = &#123;</span><br><span class="line">           body: getResponseMockLocalData(localData, setValue, callback, api) <span class="comment">// 生成 mock 数据</span></span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       req.respond(mockData)  <span class="comment">// 设置返回数据</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span></span><br><span class="line">     &#125;</span><br><span class="line">     req.<span class="keyword">continue</span>()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>清除缓存</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      localStorage.clear()</span><br><span class="line">      sessionStorage.clear()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="6"><li>点击刷新按钮</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.waitFor(<span class="string">".page-error__refresh-btn"</span>) <span class="comment">// 可以传 CSS 选择器，也可以传时间（单位毫秒）</span></span><br><span class="line"><span class="keyword">await</span> page.click(<span class="string">".page-error__refresh-btn"</span>)</span><br></pre></td></tr></table></figure><p>在模拟点击刷新按钮之前，需等待按钮渲染完成，再触发按钮点击。（防止刷新页面后，DOM 还未渲染完成的情况下，因找不到 DOM 导致报错）</p><ol start="7"><li>取消拦截，恢复网络</li></ol><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.setRequestInterception(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure><h3 id="运行脚本及调试" class="post-heading"><a href="#运行脚本及调试" class="headerlink" title="运行脚本及调试"></a>运行脚本及调试<a class="post-anchor" href="#运行脚本及调试" aria-hidden="true"></a></h3><p>由于第一阶段的测试工具尚未平台化，自动化测试流程先通过在终端输入命令行，运行脚本的方式启动。</p><p>在项目的 package.json 文件中，使用 scripts 字段定义脚本命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"test:real"</span>: <span class="string">"node ./pages/index/index.js"</span>,</span><br><span class="line">   <span class="string">"test:mock"</span>: <span class="string">"node ./pages/index-mock/index.js"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p><strong>运行：</strong></p><p>在终端切入到项目根目录路径，输入以下命令行，就可以启动测试工具，运行测试脚本。</p><pre><code>- npm run test:real                     // 接口真实返回的数据测试
- npm run test:mock                     // 使用本地 mock 数据测试
</code></pre><p><strong>调试：</strong></p><p>开启调试模式之前，需要先了解 <code>Headless Chrome</code>。</p><p><code>Headless Chrome</code> ，无头模式，浏览器的无界面形态，可以在不打开浏览器的前提下，在命令行中运行测试脚本，能够完全像真实浏览器一样完成用户所有操作，不用担心运行测试脚本时浏览器受到外界的干扰，也不需要借助任何显示设备，使自动化测试更稳定。</p><p><code>Puppeteer</code> 默认以无头模式运行。</p><p>那么要开启调试模式，就必须取消无头模式，在打开浏览器的场景下，进行自动化测试。因此，在命令行脚本中增加了“取消无头模式”和“打开开发者工具”的参数，测试脚本通过获取到的参数，决定是否开启调试模式。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> headless = process.argv[<span class="number">2</span>] !== <span class="string">'head'</span>  <span class="comment">// 获取是否开启无头模式参数</span></span><br><span class="line"><span class="keyword">const</span> devtools = process.argv[<span class="number">3</span>] === <span class="string">'dev'</span>   <span class="comment">// 获取是否打开开发者工具参数</span></span><br><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">      executablePath: browserPath,</span><br><span class="line">      headless,</span><br><span class="line">      devtools</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>在终端切入到项目根目录路径，输入以下命令行，就可以开启调试模式，运行测试脚本。</p><pre><code>- npm run test:mock head            // 打开 Chromium 窗口
- npm run test:mock head dev        // 打开 Chromium 窗口 和 开发者工具窗口
</code></pre><ul><li><code>head</code> 参数：取消无头模式，打开 Chromium 窗口运行脚本；</li><li><code>head dev</code> 参数：在打开 Chromium 窗口运行脚本，并打开 Devtools 窗口，开启调试模式。</li></ul><h3 id="测试结果" class="post-heading"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果<a class="post-anchor" href="#测试结果" aria-hidden="true"></a></h3><p><strong>人工比对截图结果：</strong><br><img src="https://img13.360buyimg.com/ling/jfs/t1/86605/32/10488/1118934/5e1b0570E6d8d09f1/ef1885490c8fd917.png" alt="测试结果图"></p><p><strong>运行脚本示例：</strong></p><p><img src="https://storage.360buyimg.com/ling-gif/自动化2_1587448409255_628.gif" alt="方案流程图"></p><h2 id="更多测试场景实现" class="post-heading"><a href="#更多测试场景实现" class="headerlink" title="更多测试场景实现"></a>更多测试场景实现<a class="post-anchor" href="#更多测试场景实现" aria-hidden="true"></a></h2><p><strong>1. 截取从页面顶部到指定 DOM 之间的区域（内容可能超出一屏的长图）</strong></p><p>Puppeteer 提供了四种截图方式：</p><pre><code>（1）截取一屏内容（默认普通截屏）；
（2）截取指定 DOM；
（3）截取全屏；
（4）指定裁剪区域，可设置 x、y、width、height。 x, y 是相对页面左上角。但只能截取一屏的内容，超出一屏不展示。
</code></pre><p>基于第四种方法进行改造：</p><ol><li>通过原生 JavaScript 的 getBoundingClientRect() 方法获取到指定 DOM 的 x，y 坐标值；</li><li>通过 page.setViewport() 重置视口的高度；</li><li>调用截图 API 生成截图。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">screenshotToElement</span> (<span class="params">page, selector, path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> page.waitForSelector(selector)</span><br><span class="line">      <span class="keyword">let</span> clip = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">selector</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> element = <span class="built_in">document</span>.querySelector(selector)</span><br><span class="line">        <span class="keyword">let</span> &#123; x, y, width, height &#125; = element.getBoundingClientRect()</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          x: <span class="number">0</span>,</span><br><span class="line">          y: <span class="number">0</span>,</span><br><span class="line">          width,</span><br><span class="line">          height: M(y),  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, selector)</span><br><span class="line">      <span class="keyword">await</span> page.setViewport(clip)</span><br><span class="line">      <span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">        path: path,</span><br><span class="line">        clip: clip</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><code>height: y</code>：截到指定 DOM 的顶部，不包含该 DOM；</li><li><code>height: y + height</code>： 截到指定 DOM 的底部，包含该 DOM；</li><li>原生 Javascript 的 getBoundingClientRect() 方法获取 DOM 元素定位和宽高值可能是小数，而 Puppeteer 的 setViewport() 设置视口方法不支持小数，所以需要对获取到的 DOM 元素定位信息取整。</li></ul><p><strong>2. 模拟不同渠道，如：手Q场景：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 设置 UA </span><br><span class="line">await page.setUserAgent(<span class="string">"Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 like Mac OS X) AppleWebKit/602.4.6 (KHTML, like Gecko) Mobile/14D27 QQ/6.7.1.416 V1_IPH_SQ_6.7.1_1_APP_A Pixel/750 Core/UIWebView NetType/4G QBWebViewType/1"</span>)</span><br></pre></td></tr></table></figure><p><strong>3. 滚动页面</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">(top)</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, top)</span><br><span class="line">&#125;, top)</span><br></pre></td></tr></table></figure><p>page.evaluate(pageFunction, …args)：在当前页面实例上下文中执行 JavaScript 代码</p><p><strong>4. 监听页面崩溃事件</strong><br></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 当页面崩溃时触发</span><br><span class="line">page.<span class="literal">on</span>(<span class="string">'error'</span>, <span class="function"><span class="params">(e)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><h2 id="结语" class="post-heading"><a href="#结语" class="headerlink" title="结语"></a>结语<a class="post-anchor" href="#结语" aria-hidden="true"></a></h2><p>第一阶段的 H5 自动化之路告一段落，容灾演习已实现了半自动化，可通过在终端运行测试脚本，模拟异常场景自动生成截图，再配合人工比对截图操作，判断演习结果是否符合预期。目前已投入到每个月的容灾演习中使用。</p><p>随着京喜业务的迭代，页面也将更新改版，因此测用例也需要持续维护和更新。后续将持续优化自动化工具，共享测试脚本、在生成截图的基础上自动比对测试结果是否符合预期、数据入库、将测试结果转化成文档，自动发送邮件等等。基于容灾演习的自动化测试，还可扩展广告位的监测，数据上报监自动化测试……</p><p>对于京喜首页自动化测试之路，远没有结束，还有很多可以优化和扩展的地方，接下来分阶段持续优化自动化测试工具，敬请期待！</p><blockquote><p>相关链接</p></blockquote><blockquote><p><a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/" target="_blank" rel="noopener">Puppeteer</a></p></blockquote><div class="post-tags" style="display:none"><a href="/tags/H5/">H5</a> <a href="/tags/自动化/">自动化</a> <a href="/tags/测试/">测试</a></div><div class="post-categories" style="display:none"><a href="/cates/Web开发/">Web开发</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2020/05/06/jingxi-automated-testing/">https://aotu.io/notes/2020/05/06/jingxi-automated-testing/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2021-02-02T07:48:05.250Z">上次更新：2021-02-02 15:48:05</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2020/05/12/file-upload/" title="大规格文件的上传优化">大规格文件的上传优化 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2020/04/27/taro-vs-jd/" title="京东小程序 Taro 开发对比原生开发测评"><i class="fa fa-chevron-left"></i> 京东小程序 Taro 开发对比原生开发测评</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"bm90ZXMvMjAyMC8wNS8wNi9qaW5neGktYXV0b21hdGVkLXRlc3",owner:"o2team",repo:"o2team.github.io",title:"京喜前端自动化测试之路",body:"https://aotu.io/notes/2020/05/06/jingxi-automated-testing/index.html\n\n",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["zhangxiang910"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdrd.jd.com" target="_blank" title="京东零售设计服务平台">京东零售设计服务平台</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2021. All Rights Reserved.</p><p><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>