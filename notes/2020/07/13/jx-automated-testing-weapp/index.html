<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>京喜前端自动化测试之路(小程序篇) | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="测试,自动化,小程序,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="如果你已经阅读过 “京喜前端自动化测试之路（一）”，可跳过前言部分阅读。 前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景"><meta name="keywords" content="小程序,自动化,测试"><meta property="og:type" content="article"><meta property="og:title" content="京喜前端自动化测试之路(小程序篇)"><meta property="og:url" content="https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="如果你已经阅读过 “京喜前端自动化测试之路（一）”，可跳过前言部分阅读。 前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://img12.360buyimg.com/ling/jfs/t1/135923/16/3702/120848/5efed886Efde1a07c/038c077946116c17.png"><meta property="og:image" content="https://img11.360buyimg.com/ling/jfs/t1/124446/26/6137/151407/5eff01eaEc266d202/88b5778d8ecfbaa1.png"><meta property="og:image" content="https://img13.360buyimg.com/ling/jfs/t1/114970/12/11387/1335848/5efde296Ed4389d71/f66d856e2efe80d9.png"><meta property="og:image" content="https://storage.360buyimg.com/ling-gif/weappgif_1593682251201_464.gif"><meta property="og:image" content="https://img20.360buyimg.com/ling/jfs/t1/128516/17/6381/352303/5f028bbdEf98e7d41/ad833350c1bc58b7.png"><meta property="og:image" content="https://img20.360buyimg.com/ling/jfs/t1/138383/16/2263/34736/5f028bbdEd021abf3/fb3f20f854890148.png"><meta property="og:updated_time" content="2021-02-02T07:48:05.250Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="京喜前端自动化测试之路(小程序篇)"><meta name="twitter:description" content="如果你已经阅读过 “京喜前端自动化测试之路（一）”，可跳过前言部分阅读。 前言京喜（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。 容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景"><meta name="twitter:image" content="https://img12.360buyimg.com/ling/jfs/t1/135923/16/3702/120848/5efed886Efde1a07c/038c077946116c17.png"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="https://img13.360buyimg.com/ling/jfs/t1/130678/30/4400/473491/5f0c3ddbEc4e492b3/fdcf7cca53b96a67.png" alt="京喜前端自动化测试之路(小程序篇)"></div><header class="post-hd"><h1 class="post-tit">京喜前端自动化测试之路(小程序篇)</h1><div class="post-meta">by <a target="_blank" href="https://github.com/zhangxiang910" class="post-author">阿翔</a> on <span>2020-07-13</span></div><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><p>如果你已经阅读过 “<a href="https://mp.weixin.qq.com/s/VhvXTNuM7TSfFtzBVmhTyg" target="_blank" rel="noopener">京喜前端自动化测试之路（一）</a>”，可跳过前言部分阅读。</p><h2 id="前言" class="post-heading"><a href="#前言" class="headerlink" title="前言"></a>前言<a class="post-anchor" href="#前言" aria-hidden="true"></a></h2><p><strong>京喜</strong>（原京东拼购）项目，作为京东战略级业务，拥有千万级别的流量入口。为了保障线上业务的稳定运行，每月例行开展前端容灾演习，主要包含小程序及 H5 版本，要求各页面各模块在异常情况下进行适当的降级处理，不能出现空窗、样式错乱、不合理的错误提示等体验问题。</p><p>容灾演习是一项长期持续的工作，且涉及页面功能及场景多，人工的切换场景模拟异常导致演习效率较低，因此想通过开发自动化测试工具来提升演习效率，让容灾演习工作随时可以轻松开展。由于京喜 H5 和小程序场景差异比较大，自动化测试分 H5 和小程序两部分进行。前期已经分享过 H5 的自动化测试方案 —— <code>京喜前端自动化测试之路（一）</code>，本文则主要讲述小程序版的自动化测试方案。</p><p>综上所述，我们希望京喜小程序自动化测试工具可以提供以下功能：</p><ol><li>访问目标页面，对页面进行截图；</li><li>模拟用户点击、滑动页面操作；</li><li>网络拦截、模拟异常情况（接口响应码 500、接口返回数据异常）；</li><li>操作缓存数据（模拟有无缓存的场景等）。</li></ol><h2 id="小程序自动化-SDK" class="post-heading"><a href="#小程序自动化-SDK" class="headerlink" title="小程序自动化 SDK"></a>小程序自动化 SDK<a class="post-anchor" href="#小程序自动化-SDK" aria-hidden="true"></a></h2><p>聊到小程序的自动化工具，微信官方为开发者提供了一套小程序自动化 SDK —— <a href="https://www.npmjs.com/package/miniprogram-automator" target="_blank" rel="noopener">miniprogram-automator</a> ， 我们不需要关注技术选型，可直接使用。</p><blockquote><p>小程序自动化 SDK 为开发者提供了一套通过外部脚本操控小程序的方案，从而实现小程序自动化测试的目的。</p></blockquote><blockquote><p>如果你之前使用过 <a href="https://www.selenium.dev/projects/" target="_blank" rel="noopener">Selenium WebDriver</a> 或者 <a href="https://pptr.dev/" target="_blank" rel="noopener">Puppeteer</a>，那你可以很容易快速上手。小程序自动化 SDK 与它们的工作原理是类似的，主要区别在于控制对象由浏览器换成了小程序。</p></blockquote><p><strong>特性</strong></p><p>通过该 SDK，你可以做到以下事情：</p><ul><li>控制小程序跳转到指定页面</li><li>获取小程序页面数据</li><li>获取小程序页面元素状态</li><li>触发小程序元素绑定事件</li><li>往 AppService 注入代码片段</li><li>调用 wx 对象上任意接口</li><li>…</li></ul><p><strong>示例</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> automator = <span class="built_in">require</span>(<span class="string">'miniprogram-automator'</span>)</span><br><span class="line"></span><br><span class="line">automator</span><br><span class="line">    .launch(&#123;</span><br><span class="line">        cliPath: <span class="string">'/Applications/wechatwebdevtools.app/Contents/MacOS/cli'</span>, <span class="comment">// 工具 cli 位置（绝对路径）</span></span><br><span class="line">        projectPath: <span class="string">'path/to/project'</span>, <span class="comment">// 项目文件地址（绝对路径）</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="keyword">async</span> miniProgram =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> miniProgram.reLaunch(<span class="string">'/pages/index/index'</span>)</span><br><span class="line">        <span class="keyword">await</span> page.waitFor(<span class="number">500</span>)</span><br><span class="line">        <span class="keyword">const</span> element = <span class="keyword">await</span> page.$(<span class="string">'.banner'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">await</span> element.attribute(<span class="string">'class'</span>))</span><br><span class="line">        <span class="keyword">await</span> element.tap()</span><br><span class="line">        <span class="keyword">await</span> miniProgram.close()</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p></p><p>综上所述，我们选择使用官方维护的 SDK —— <code>miniprogram-automator</code> 开发小程序的自动化测试工具，通过 SDK 提供的一系列 API ，实现访问目标页面、模拟异常场景、生成截图的过程自动化。最后再通过人工比对截图，判断页面降级处理是否符合预预期、用户体验是否友好。</p><h2 id="实现方案" class="post-heading"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案<a class="post-anchor" href="#实现方案" aria-hidden="true"></a></h2><p><strong>原来的容灾演习过程：</strong></p><p>小程序的通信方式改成 HTTPS ，通过 <a href="https://wproxy.org/whistle/" target="_blank" rel="noopener">Whistle</a> 对接口返回进行修改来模拟异常情况，验证各页面各模块的降级处理符合预期。</p><p><strong>现阶段的容灾演习自动化方案：</strong></p><p>我们将容灾演习过程分为<code>自动化流程</code>和<code>人工操作</code>两部分。</p><p><strong>自动化流程：</strong></p><ol><li>启动微信开发者工具（开发版）;</li><li>访问目标页面，模拟用户点击、滑动等行为；</li><li>模拟异常场景：拦截网络请求，修改接口返回数据（接口返回 500、异常数据等）；</li><li>生成截图。</li></ol><p><strong>人工操作：</strong></p><p>自动化脚本执行完毕后，人工比对各个场景的截图，判断是否符合预期。</p><p><strong>方案流程图：</strong><br><img src="https://img12.360buyimg.com/ling/jfs/t1/135923/16/3702/120848/5efed886Efde1a07c/038c077946116c17.png" alt="xxx"></p><h2 id="开发实录" class="post-heading"><a href="#开发实录" class="headerlink" title="开发实录"></a>开发实录<a class="post-anchor" href="#开发实录" aria-hidden="true"></a></h2><h3 id="快速创建测试用例" class="post-heading"><a href="#快速创建测试用例" class="headerlink" title="快速创建测试用例"></a>快速创建测试用例<a class="post-anchor" href="#快速创建测试用例" aria-hidden="true"></a></h3><p>为了提高测试脚本的可维护性、扩展性，我们将测试用例的信息都配置到 JSON 文件中，这样编写测试脚本的时候，我们只需关注测试流程的实现。</p><p>测试用例 JSON 数据配置包括<code>公用数据（global）</code>和<code>私有数据</code>：</p><p><code>公用数据（global）</code>：各测试用例都需要用到的数据，如：模拟访问的目标页面地址、名字、描述、设备类型等。</p><p><code>私有数据</code>： 各测试用例特定的数据，如测试模块信息、api 地址、测试场景、预期结果、截图名字等数据。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"global"</span>: &#123;</span><br><span class="line">    <span class="string">"url"</span>: <span class="string">"/pages/index/index"</span>,</span><br><span class="line">    <span class="string">"pageName"</span>: <span class="string">"index"</span>,</span><br><span class="line">    <span class="string">"pageDesc"</span>: <span class="string">"首页"</span>,</span><br><span class="line">    <span class="string">"device"</span>: <span class="string">"iPhone X"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"homePageApi"</span>: &#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"module"</span>: <span class="string">"home_page_api"</span>,</span><br><span class="line">    <span class="string">"moduleDesc"</span>: <span class="string">"首页主接口"</span>,</span><br><span class="line">    <span class="string">"api"</span>: <span class="string">"https://xxx"</span>,</span><br><span class="line">    <span class="string">"operation"</span>: <span class="string">"模拟响应码 500"</span>,</span><br><span class="line">    <span class="string">"expectRules"</span>: [</span><br><span class="line">      <span class="string">"1. 有缓存数据，显示容灾兜底数据"</span>,</span><br><span class="line">      <span class="string">"2. 请求容灾接口，显示容灾兜底数据"</span>,</span><br><span class="line">      <span class="string">"3. 容灾接口异常，显示信异常息、刷新按钮"</span>,</span><br><span class="line">      <span class="string">"4. 恢复网络，点击刷新按钮，显示正常数据"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"screenshot"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"normal"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"正常场景"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_cache"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"有缓存-主接口返回500"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_no_cache"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"无缓存-主接口返回500-容灾兜底数据"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_no_cache_500_disaster"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"无缓存-主接口返回500-容灾兜底接口返回500"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"500_no_cache_recover"</span>,</span><br><span class="line">        <span class="string">"desc"</span>: <span class="string">"无缓存-返回500-恢复网络"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写测试脚本" class="post-heading"><a href="#编写测试脚本" class="headerlink" title="编写测试脚本"></a>编写测试脚本<a class="post-anchor" href="#编写测试脚本" aria-hidden="true"></a></h3><p>我们以京喜首页主接口的测试用例为例子，通过模拟主接口返回 500 响应码的异常场景，验证主接口的异常处理机制是否完善、用户体验是否友好。</p><p><strong>预期效果：</strong></p><ul><li>主接口异常，有缓存数据，显示缓存数据</li><li>主接口异常，无缓存数据，则请求容灾接口，显示容灾兜底数据</li><li>主接口、容灾接口异常，无缓存数据，显示信异常息、刷新按钮</li><li>恢复网络，点击刷新按钮，显示正常数据</li></ul><p><strong>测试流程：</strong></p><p><img src="https://img11.360buyimg.com/ling/jfs/t1/124446/26/6137/151407/5eff01eaEc266d202/88b5778d8ecfbaa1.png" alt="ddd"></p><p><strong>场景实现：</strong></p><p>根据测试流程以及配置的测试用例信息，编写测试脚本，模拟测试用例场景:</p><ol><li>访问页面</li></ol><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> miniProgram = <span class="keyword">await</span> automator.launch(&#123;</span><br><span class="line">      cliPath: <span class="string">'/Applications/wechatwebdevtools.app/Contents/MacOS/cli'</span>, <span class="comment">// 开发者工具命令行工具（绝对路径）</span></span><br><span class="line">      projectPath: <span class="string">'jx_project'</span>, <span class="comment">// 项目地址（绝对路径）</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">await</span> miniProgram.reLaunch(<span class="string">'/pages/index/index'</span>)</span><br></pre></td></tr></table></figure><ol start="2"><li>生成截图</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">await</span> <span class="selector-tag">miniProgram</span><span class="selector-class">.screenshot</span>(&#123;</span><br><span class="line">    <span class="attribute">path</span>: <span class="string">'jx_weapp_index_home_page_500.png'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>模拟异常数据</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getMockData = (url, mockType, mockValue) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = &#123;</span><br><span class="line">      <span class="keyword">data</span>: <span class="string">'test'</span>,</span><br><span class="line">      cookies: [],</span><br><span class="line">      header: &#123;&#125;,</span><br><span class="line">      statusCode: <span class="number">200</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch (mockType) &#123;</span><br><span class="line">      case <span class="string">'data'</span>:</span><br><span class="line">        result.<span class="keyword">data</span> = getMockResponse(url, mockValue) <span class="comment">// 修改返回数据</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      case <span class="string">'cookies'</span>:</span><br><span class="line">        result.cookies = mockValue <span class="comment">// 修改返回数据</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      case <span class="string">'header'</span>:</span><br><span class="line">        result.header = mockValue <span class="comment">// 修改返回响应头</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      case <span class="string">'statusCode'</span>:</span><br><span class="line">        result.statusCode = mockValue <span class="comment">// 修改返回响应头</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      rule: url,</span><br><span class="line">      result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 修改本地存储数据</span></span><br><span class="line"> <span class="keyword">const</span> mockValue = &#123;</span><br><span class="line">     <span class="keyword">data</span>: &#123;</span><br><span class="line">         modules: [&#123;</span><br><span class="line">            tpl:<span class="string">'3000'</span>,</span><br><span class="line">            content: []</span><br><span class="line">         &#125;]</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> mockData =  [</span><br><span class="line">    getMockData(api1, <span class="string">'statusCode'</span>, <span class="number">500</span>), <span class="comment">// 模拟接口返回 500</span></span><br><span class="line">    getMockData(api2, <span class="string">'data'</span>, mockValue) <span class="comment">// 模拟接口返回异常数据</span></span><br><span class="line">    ...</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><ol start="4"><li>拦截接口请求，修改返回数据</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> interceptAPI = <span class="keyword">async</span> (miniProgram, url, mockData) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> miniProgram.mockWxMethod(</span><br><span class="line">        <span class="string">'request'</span>,</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">obj, data</span>) </span>&#123; <span class="comment">// 处理返回函数</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = data.length; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> item = data[i]</span><br><span class="line">            <span class="comment">// 命中规则的返回 mockData</span></span><br><span class="line">            <span class="keyword">if</span> (obj.url.indexOf(item.rule) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> item.result</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 没命中规则的真实访问后台</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            obj.success = <span class="function"><span class="params">res</span> =&gt;</span> resolve(res)</span><br><span class="line">            obj.fail = <span class="function"><span class="params">res</span> =&gt;</span> resolve(res)</span><br><span class="line">            / origin 指向原始方法</span><br><span class="line">            <span class="keyword">this</span>.origin(obj)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;,</span><br><span class="line">        mockData, <span class="comment">// 传入 mock 数据</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`拦截【<span class="subst">$&#123;url&#125;</span>】API报错`</span>)</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> interceptAPI(interceptAPI, url, mockData)</span><br></pre></td></tr></table></figure><ul><li><code>miniProgram.mockWxMethod</code>：覆盖 wx 对象上指定方法的调用结果。利用该 API，可以覆盖 wx.request API，拦截网络请求，修改返回数据。</li><li>目前是本地存储一份接口返回的 JSON 数据，通过修改本地的 JSON 数据生成 mockData。若需要修改接口实时返回的数据，可在 <code>obj.success</code> 中获取实时数据并修改。</li></ul><ol start="5"><li>清除缓存</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> miniProgram.callWxMethod(<span class="string">'clearStorage'</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="string">`清除缓存报错: `</span>)</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>点击刷新按钮</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> miniProgram.currentPage()</span><br><span class="line"><span class="keyword">const</span> $refreshBtn = <span class="keyword">await</span> page.$(<span class="string">'.page-error__refresh-btn'</span>) <span class="comment">// 同 WXSS，仅支持部分 CSS 选择器</span></span><br><span class="line"><span class="keyword">await</span> $refreshBtn.tap()</span><br></pre></td></tr></table></figure><ol start="7"><li>取消拦截，恢复网络</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cancelInterceptAPI = <span class="keyword">async</span> (miniProgram) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> miniProgram.restoreWxMethod(<span class="string">'request'</span>) <span class="comment">// 重置 wx.request ，消除 mockWxMethod 调用的影响。</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`取消拦截【<span class="subst">$&#123;url&#125;</span>】API报错`</span>)</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> cancelInterceptAPI(miniProgram)</span><br></pre></td></tr></table></figure><h3 id="启动自动化测试" class="post-heading"><a href="#启动自动化测试" class="headerlink" title="启动自动化测试"></a>启动自动化测试<a class="post-anchor" href="#启动自动化测试" aria-hidden="true"></a></h3><p>由于第一阶段的测试工具尚未平台化，先通过在终端输入命令行，运行脚本的方式，启动自动化测试。</p><p>在项目的 package.json 文件中，使用 scripts 字段定义脚本命令：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">   <span class="string">"start"</span>: <span class="string">"node pages/index/index.js"</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p><strong>运行环境：</strong></p><ul><li>安装 Node.js 并且版本大于 8.0</li><li>基础库版本为 2.7.3 及以上</li><li>开发者工具版本为 1.02.1907232 及以上</li></ul><p><strong>运行：</strong></p><p>在终端切入到项目根目录路径，输入以下命令行，就可以启动测试工具，运行测试脚本。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">run</span><span class="bash"> start</span></span><br></pre></td></tr></table></figure><h3 id="测试结果" class="post-heading"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果<a class="post-anchor" href="#测试结果" aria-hidden="true"></a></h3><p><strong>人工比对截图结果：</strong></p><p><img src="https://img13.360buyimg.com/ling/jfs/t1/114970/12/11387/1335848/5efde296Ed4389d71/f66d856e2efe80d9.png" alt="测试结果图"></p><p><strong>运行脚本示例：</strong></p><p><img src="https://storage.360buyimg.com/ling-gif/weappgif_1593682251201_464.gif" alt="运行脚本示例"></p><h3 id="使用-SDK，你必须知道-Shadow-DOM" class="post-heading"><a href="#使用-SDK，你必须知道-Shadow-DOM" class="headerlink" title="使用 SDK，你必须知道 Shadow DOM"></a>使用 SDK，你必须知道 Shadow DOM<a class="post-anchor" href="#使用-SDK，你必须知道-Shadow-DOM" aria-hidden="true"></a></h3><p>当我们想控制小程序页面时，需获取页面实例 page，利用 page 提供的方法控制页面内的元素。</p><p>比如，当我们想点击页面中搜索框时，我们一般会这么做：<br></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const<span class="built_in"> page </span>= await miniProgram.currentPage()</span><br><span class="line">const <span class="variable">$searchBar</span> = await page.$(<span class="string">'search-bar'</span>)</span><br><span class="line">await <span class="variable">$searchBar</span>.tap()</span><br></pre></td></tr></table></figure><p></p><p>但这样真的可行吗？答案是：</p><p>试试就知道了。</p><p>运行这段测试脚本后生成的截图：</p><p><img src="https://img20.360buyimg.com/ling/jfs/t1/128516/17/6381/352303/5f028bbdEf98e7d41/ad833350c1bc58b7.png" alt="没有触发点击"></p><p>我们得到的结果是：根本没有触发点击事件。</p><p><strong>Shadow DOM：</strong></p><p>它是 HTML 的一个规范，它允许在文档( document )渲染时插入一颗DOM元素子树，但是这个子树不在主 DOM 树中。</p><p>它允许浏览器开发者封装自己的 HTML 标签、css 样式和特定的 javascript 代码、同时开发人员也可以创建类似 <code>&lt;input&gt;、&lt;video&gt;、&lt;audio&gt;</code> 等、这样的自定义的一级标签。创建这些标签内容相关的 API，可以被叫做 Web Component。</p><p>Shadow DOM 的关键所在，它可以将一个隐藏的、独立的 DOM 附加到一个元素上。</p><ul><li><code>Shadow host:</code> 一个常规 DOM 节点，Shadow DOM 会被附加到这个节点上。它是 Shadow DOM 的一个宿主元素。比如：<code>&lt;input /&gt;、&lt;audio&gt;、&lt;video&gt;</code> 标签，就是 Shadow DOM 的宿主元素。</li><li><code>Shadow tree:</code> Shadow DOM 内部的 DOM 树。</li><li><code>Shadow root:</code> Shadow DOM 的根节点。通过 <code>createShadowRoot</code> 返回的文档片段被称为 shadow-root , 它和它的后代元素，都会对用户隐藏。</li></ul><p>回到我们刚刚的问题：</p><p>由于小程序使用了 Shadow DOM，因此我们不能直接通过 page 实例获取到搜索框真实 DOM。我们看到的页面中渲染的搜索框，实际上是一个 Shadow DOM。因此，我们必须先获取到搜索框 Shadow DOM 的宿主元素，并通过宿主元素获取到搜索框真实的 DOM，最后触发真实 DOM 的点击事件。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const<span class="built_in"> page </span>= await miniProgram.currentPage()</span><br><span class="line">const <span class="variable">$searchBarShadow</span> = await page.$(<span class="string">'search-bar'</span>)</span><br><span class="line">const <span class="variable">$searchBar</span> = await <span class="variable">$searchBarShadow</span>.$(<span class="string">'.search-bar'</span>)</span><br><span class="line">const &#123; height &#125; = await <span class="variable">$searchBar</span>.size()</span><br></pre></td></tr></table></figure><p>运行这段测试脚本后生成的截图：</p><p><img src="https://img20.360buyimg.com/ling/jfs/t1/138383/16/2263/34736/5f028bbdEd021abf3/fb3f20f854890148.png" alt="搜索页"></p><p>从截图可以看到，触发了搜索框的点击事件。</p><h2 id="更多测试场景实现" class="post-heading"><a href="#更多测试场景实现" class="headerlink" title="更多测试场景实现"></a>更多测试场景实现<a class="post-anchor" href="#更多测试场景实现" aria-hidden="true"></a></h2><p><strong>1. 下拉刷新</strong><br></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pullDownRefresh = <span class="keyword">async</span> (miniProgram) =&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">await</span> miniProgram.callWxMethod(<span class="string">'startPullDownRefresh'</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">'下拉刷新操作失败'</span>)</span><br><span class="line">      <span class="built_in">console</span>.error(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>2. 滚动到指定 DOM</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> miniProgram.currentPage() <span class="comment">// 获取页面实例</span></span><br><span class="line"><span class="keyword">const</span> $recommendTabShadow = <span class="keyword">await</span> page.$(<span class="string">'recommend-tab'</span>) <span class="comment">// 获取Shadow DOM</span></span><br><span class="line"><span class="keyword">const</span> $recommendTab = <span class="keyword">await</span> $recommendTabShadow.$(<span class="string">'.recommend'</span>) <span class="comment">// 获取真实 DOM</span></span><br><span class="line"><span class="keyword">const</span> &#123; top &#125; = <span class="keyword">await</span> $recommendTab.offset() <span class="comment">// 获取DOM 定位</span></span><br><span class="line"><span class="keyword">await</span> miniProgram.pageScrollTo(top) <span class="comment">// 滚动到指定DOM</span></span><br></pre></td></tr></table></figure><p><strong>3. 事件</strong></p><ul><li>日志打印；</li><li>监听页面崩溃事件</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 日志打印时触发</span></span><br><span class="line">miniProgram.on(<span class="string">'console'</span>, <span class="function"><span class="params">msg</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg.type, msg.args)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 页面 JS 出错时触发</span></span><br><span class="line">page.on(<span class="string">'error'</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="结语" class="post-heading"><a href="#结语" class="headerlink" title="结语"></a>结语<a class="post-anchor" href="#结语" aria-hidden="true"></a></h2><p>第一阶段的小程序自动化测试之路告一段落。和 H5 自动化测试一样，容灾演习已实现了半自动化，可通过在终端运行测试脚本，模拟异常场景自动生成截图，再配合人工比对截图操作，判断演习结果是否符合预期。目前已投入到每个月的容灾演习中使用。</p><p>由于 H5 和小程序的差异比较大，第一阶段的自动化测试分两端进行，测试脚本语法也是截然不同，需要同时维护两套测试工具。为了降低维护成本，提升测试脚本的开发效率，我们正在研发第二阶段的自动化测试工具，一套代码支持两端测试，目前已经进入内测阶段。更多彩蛋，敬请期待第二阶段自动化测试工具——多端自动化测试 SDK 。</p><div class="post-tags" style="display:none"><a href="/tags/小程序/">小程序</a> <a href="/tags/自动化/">自动化</a> <a href="/tags/测试/">测试</a></div><div class="post-categories" style="display:none"><a href="/cates/小程序/">小程序</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/">https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2021-02-02T07:48:05.250Z">上次更新：2021-02-02 15:48:05</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2020/07/17/webpack-analize/" title="Webpack原理浅析">Webpack原理浅析 <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2020/06/30/taro-3-0-0/" title="Taro 3 正式版发布：开放式跨端跨框架解决方案"><i class="fa fa-chevron-left"></i> Taro 3 正式版发布：开放式跨端跨框架解决方案</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"bm90ZXMvMjAyMC8wNy8xMy9qeC1hdXRvbWF0ZWQtdGVzdGluZy",owner:"o2team",repo:"o2team.github.io",title:"京喜前端自动化测试之路(小程序篇)",body:"https://aotu.io/notes/2020/07/13/jx-automated-testing-weapp/index.html\n\n",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["zhangxiang910"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdrd.jd.com" target="_blank" title="京东零售设计服务平台">京东零售设计服务平台</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2021. All Rights Reserved.</p><p><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>