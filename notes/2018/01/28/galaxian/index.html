<!DOCTYPE html><html class="theme-lattice"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><title>H5游戏开发：FC小蜜蜂 | Aotu.io「凹凸实验室」</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="author" content="凹凸实验室"><meta name="designer" content="凹凸实验室"><meta name="rating" content="general"><meta name="format-detection" content="telephone=yes"><meta name="robots" content="index, follow"><meta baidu-gxt-verify-token="2b74a5aea155a215abea8547f929190c"><meta name="keywords" content="Phaser,H5游戏开发,凹凸实验室,Aotu,前端开发,全栈开发,IOS开发,Android开发"><link rel="canonical" href="https://aotu.io/notes/2018/01/28/galaxian/index.html"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon-32x32.png"><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon-48x48.png"><link rel="manifest" href="/img/manifest.json"><meta name="mobile-web-app-capable" content="yes"><meta name="theme-color" content="#2f83cd"><meta name="application-name" content="Aotu.io"><link rel="apple-touch-icon" sizes="57x57" href="/img/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/img/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/img/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/img/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/img/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/img/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/img/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="167x167" href="/img/apple-touch-icon-167x167.png"><link rel="apple-touch-icon" sizes="180x180" href="/img/apple-touch-icon-180x180.png"><link rel="apple-touch-icon" sizes="1024x1024" href="/img/apple-touch-icon-1024x1024.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="apple-mobile-web-app-title" content="Aotu.io"><meta name="msapplication-TileColor" content="#fff"><meta name="msapplication-TileImage" content="/img/mstile-144x144.png"><meta name="msapplication-config" content="/img/browserconfig.xml"><meta property="wb:webmaster" content="a1686eb81db284d5"><meta name="wechat-logo" content="//misc.aotu.io/ONE-SUNDAY/galaxian/galaxian_200x200.jpg"><meta name="wechat-title" content="H5游戏开发：FC小蜜蜂"><meta name="wechat-desc" content="使用 Phaser 游戏引擎开发，主要介绍游戏引擎的功能及游戏逻辑"><link rel="dns-prefetch" href="//storage.360buyimg.com"><link rel="dns-prefetch" href="//img10.360buyimg.com"><link rel="dns-prefetch" href="//img11.360buyimg.com"><link rel="dns-prefetch" href="//img12.360buyimg.com"><link rel="dns-prefetch" href="//img13.360buyimg.com"><link rel="dns-prefetch" href="//img14.360buyimg.com"><link rel="dns-prefetch" href="//img20.360buyimg.com"><link rel="dns-prefetch" href="//img30.360buyimg.com"><link rel="dns-prefetch" href="//misc.aotu.io"><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" href="/atom.xml" title="Aotu.io"><meta name="description" content="前言说起任天堂 FC 那是充满我们童年寒暑假的回忆，那时候没有正版红白机，玩的是几十块一台的山寨小霸王，十块一张的卡带，玩着魂斗罗、马里奥、淘金者、快打旋风、打鸭子等等。 进入正题，今天我们来说说怎么做一个 FC 小蜜蜂游戏，游戏玩法是通过操控飞机，通过发射子弹对蜜蜂造成伤害，蜜蜂全部歼灭则视为胜利。   初始化本次游戏采用 Phaser 引擎进行开发，Phaser 是一个快速、免费、易于维护的"><meta name="keywords" content="H5游戏开发,Phaser"><meta property="og:type" content="article"><meta property="og:title" content="H5游戏开发：FC小蜜蜂"><meta property="og:url" content="https://aotu.io/notes/2018/01/28/galaxian/index.html"><meta property="og:site_name" content="Aotu.io"><meta property="og:description" content="前言说起任天堂 FC 那是充满我们童年寒暑假的回忆，那时候没有正版红白机，玩的是几十块一台的山寨小霸王，十块一张的卡带，玩着魂斗罗、马里奥、淘金者、快打旋风、打鸭子等等。 进入正题，今天我们来说说怎么做一个 FC 小蜜蜂游戏，游戏玩法是通过操控飞机，通过发射子弹对蜜蜂造成伤害，蜜蜂全部歼灭则视为胜利。   初始化本次游戏采用 Phaser 引擎进行开发，Phaser 是一个快速、免费、易于维护的"><meta property="og:locale" content="zh-cn"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/gameplay.gif"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/phaser.jpg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/state.jpeg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/background.jpeg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/contain.jpg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/createBullet.jpg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/galaxingContainer.jpg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/trigonometric_ratio.jpeg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/AABB.jpeg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/arcade.jpg"><meta property="og:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/ninjaunner.jpg"><meta property="og:updated_time" content="2021-02-02T07:48:05.246Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="H5游戏开发：FC小蜜蜂"><meta name="twitter:description" content="前言说起任天堂 FC 那是充满我们童年寒暑假的回忆，那时候没有正版红白机，玩的是几十块一台的山寨小霸王，十块一张的卡带，玩着魂斗罗、马里奥、淘金者、快打旋风、打鸭子等等。 进入正题，今天我们来说说怎么做一个 FC 小蜜蜂游戏，游戏玩法是通过操控飞机，通过发射子弹对蜜蜂造成伤害，蜜蜂全部歼灭则视为胜利。   初始化本次游戏采用 Phaser 引擎进行开发，Phaser 是一个快速、免费、易于维护的"><meta name="twitter:image" content="https://misc.aotu.io/ONE-SUNDAY/galaxian/gameplay.gif"><meta name="twitter:site" content="o2circle"><script>var App={root:"/",isHome:!1,isCate:!1,isTag:!1}</script><script>window.WechatShareData={imgUrl:"//misc.aotu.io/ONE-SUNDAY/galaxian/galaxian_200x200.jpg",link:window.location.href,title:"H5游戏开发：FC小蜜蜂",desc:"使用 Phaser 游戏引擎开发，主要介绍游戏引擎的功能及游戏逻辑"},window.WechatJSSDKURL="https://aotu.jd.com/aotu-wx-api/api/wx/jssdk/signature"</script></head><body class="page-post-detail"><div class="mod-hd"><div class="grid"><div class="mod-logo"><a href="/index.html" title="Aotu.io">Aotu.io</a></div><span class="mod-hd-toggle" id="J_hdToggle"><i class="fa fa-bars"></i></span><div class="mod-hd-main"><div class="mod-hd-inner"><nav class="mod-nav"><ul class="mod-nav-list"><li class="main-nav-item"><a href="/index.html" class="main-nav-link">首页</a></li><li class="main-nav-item"><a target="_blank" href="https://geeks.aotu.io" class="main-nav-link">极客沙龙</a></li><li class="main-nav-item"><a href="https://cases.aotu.io" class="main-nav-link">H5案例</a></li><li class="main-nav-item"><a href="/about/" class="main-nav-link">关于</a></li><li class="main-nav-item"><a href="/join/" class="main-nav-link">加入我们</a></li></ul></nav><div class="mod-search" id="J_search"><a class="fa fa-search mod-search-ico" id="J_searchTrigger" title="搜索"></a><form id="J_searchForm" method="get" class="mod-search-form" action="/search/"><input type="text" name="query" class="mod-search-ipt" id="J_searchInput" placeholder="搜索"></form></div></div></div></div></div><div class="mod-container"><div class="grid"><div class="mod-main typo"><article class="post"><div class="post-cover"><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/galaxian_900x500.jpg" alt="H5游戏开发：FC小蜜蜂"></div><header class="post-hd"><h1 class="post-tit">H5游戏开发：FC小蜜蜂</h1><div class="post-meta">by <a target="_blank" href="https://github.com/ONE-SUNDAY" class="post-author">TH</a> on <span>2018-01-28</span></div><p class="post-subtit" style="display:none"><i class="fa fa-quote-left"></i>使用 Phaser 游戏引擎开发，主要介绍游戏引擎的功能及游戏逻辑</p><span style="display:none" id="busuanzi_value_page_pv"></span></header><div class="post-content"><a id="more"></a><h2 id="前言" class="post-heading"><a href="#前言" class="headerlink" title="前言"></a>前言<a class="post-anchor" href="#前言" aria-hidden="true"></a></h2><p>说起任天堂 FC 那是充满我们童年寒暑假的回忆，那时候没有正版红白机，玩的是几十块一台的山寨小霸王，十块一张的卡带，玩着魂斗罗、马里奥、淘金者、快打旋风、打鸭子等等。</p><p>进入正题，今天我们来说说怎么做一个 FC 小蜜蜂游戏，游戏玩法是通过操控飞机，通过发射子弹对蜜蜂造成伤害，蜜蜂全部歼灭则视为胜利。</p><div style="margin:0 auto;width:fit-content"><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/gameplay.gif" alt="游戏演示"></div><h2 id="初始化" class="post-heading"><a href="#初始化" class="headerlink" title="初始化"></a>初始化<a class="post-anchor" href="#初始化" aria-hidden="true"></a></h2><p>本次游戏采用 Phaser 引擎进行开发，Phaser 是一个快速、免费、易于维护的开源 2D 游戏框架，支持 JavaScript 和 TypeScript 两种语言开发，采用 Pixi.js 引擎作为底层渲染，内置了物理引擎、粒子动画、骨骼动画等效果。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/phaser.jpg" alt="功能介绍"></p><p>在 Phaser 中有一个重要的概念，我们需要通过<strong>状态（State）</strong>来管理游戏中各个不同的场景，这也是 Phaser 官方建议的游戏代码组织方式，场景可以通过 <code>Phaser.Game.state</code> 来添加（add）和启动（start），每个场景有初始化（init）、预加载（preload）、准备就绪（create）、更新周期（update）、渲染完毕（render） 五种状态，按照顺序依次执行，同一时间只能存在一个场景，并且每个场景中至少包含五种状态中的一个。</p><p>比如我们的小蜜蜂游戏一共会分为四个场景：开始场景、游戏场景、获胜场景、失败场景</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/state.jpeg" alt="游戏场景"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> game = <span class="keyword">new</span> Phaser.Game(<span class="number">750</span>, <span class="number">1206</span>, Phaser.AUTO, <span class="string">'wrapper'</span>)</span><br><span class="line"><span class="keyword">var</span> states = &#123;&#125;</span><br><span class="line"></span><br><span class="line">states.start = &#123; <span class="comment">// 开始场景</span></span><br><span class="line">	preload: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  		...</span><br><span class="line">  		game.load.image(<span class="string">'example-1'</span>, <span class="string">'images/example-1.png'</span>)</span><br><span class="line">  		...</span><br><span class="line">	&#125;,</span><br><span class="line">  	create: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   	 	game.state.start(<span class="string">'play'</span>) <span class="comment">// 加载完成后切换到游戏场景</span></span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">states.play = &#123; ... &#125; <span class="comment">// 游戏场景</span></span><br><span class="line">states.victory = &#123; ... &#125; <span class="comment">// 胜利场景</span></span><br><span class="line">states.defeat = &#123; ... &#125; <span class="comment">// 失败场景</span></span><br><span class="line"></span><br><span class="line">game.state.add(<span class="string">'start'</span>, states.load)</span><br><span class="line">game.state.add(<span class="string">'play'</span>, states.play)</span><br><span class="line">game.state.add(<span class="string">'victory'</span>, states.victory)</span><br><span class="line">game.state.add(<span class="string">'defeat'</span> states.defeat)</span><br><span class="line">game.state.start(<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure><h2 id="无限滚屏" class="post-heading"><a href="#无限滚屏" class="headerlink" title="无限滚屏"></a>无限滚屏<a class="post-anchor" href="#无限滚屏" aria-hidden="true"></a></h2><p>在无限滚屏中，游戏背景沿着 x 轴或者 y 轴重复的滚动，从而实现飞机一直在向前飞的错觉，我们通过创建两个背景，分别初始定位到一屏和二屏的位置，在绘制（update）的过程中持续移动两张背景图的 y 轴，当监听到两个背景超出特定位置后重新定位，从而达到无限循环背景的效果。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/background.jpeg" alt="无限滚屏"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bg1 = game.add.image(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'background'</span>),</span><br><span class="line">    bg2 = game.add.image(<span class="number">0</span>, -bg1.height, <span class="string">'background'</span>)</span><br><span class="line"></span><br><span class="line">update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 持续的移动</span></span><br><span class="line">	bg1.y += <span class="number">2</span></span><br><span class="line">	bg2.y += <span class="number">2</span></span><br><span class="line">	<span class="comment">// 超出屏幕判断</span></span><br><span class="line">	<span class="keyword">if</span> (bg1.y &gt;= <span class="number">1206</span>) &#123; bg1.y = <span class="number">0</span> &#125;</span><br><span class="line">	<span class="keyword">if</span> (bg2.y &gt;= <span class="number">0</span>) &#123; bg2.y = -bg1.height &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，还有更为简便的方式，Phaser 提供了 TileSprite 平铺纹理，非常适合于这类平铺的背景，再结合 <code>autoScroll()</code> 方法，两行代码解决，另外还有一种叫 TileMaps 平铺的瓦片地图，很适合制作 FC 马里欧这类游戏，以后有机会再开一篇文章讲讲。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bg = game.add.tileSprite(<span class="number">0</span>, <span class="number">0</span>, <span class="number">750</span>, <span class="number">1206</span>, <span class="string">'background'</span>)</span><br><span class="line">bg.autoScroll(<span class="number">0</span>, <span class="number">200</span>) <span class="comment">// 水平滚动速度、垂直滚动速度</span></span><br></pre></td></tr></table></figure><h2 id="创建一架飞机" class="post-heading"><a href="#创建一架飞机" class="headerlink" title="创建一架飞机"></a>创建一架飞机<a class="post-anchor" href="#创建一架飞机" aria-hidden="true"></a></h2><p>飞机的移动我们通过键盘方向键进行控制，通过修改 x、y 值来实现位移，为了有更好的灵活性，我们使用 vx 和 vy 来控制 Sprite 的移动，vx 用于设置 Sprite 在 x 轴上的速度和方向，vy 用于设置 Sprite 在 y 轴上的速度和方向，不直接修改 Sprite 的 x 和 y 值，而是先更新速度值，然后再将这些速度值分配给 Sprite。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">airplane.vx = <span class="number">0</span></span><br><span class="line">airplane.vy = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	airplane.x += airplane.vx</span><br><span class="line">  	airplane.y += airplane.vy</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>接着监听键盘事件，需要注意的就是在弹起状态的时候要判断反向的键是否也已经弹起，避免造成互相干扰。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">left.onDown.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; airplane.vx = <span class="number">-8</span> &#125;)</span><br><span class="line">left.onUp.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">if</span> (!right.isDown) &#123; airplane.vx = <span class="number">0</span> &#125; &#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最后是限制飞机的移动范围，我们要限制飞机只在屏幕范围内移动，类似空气墙效果，通过持续监听飞机上下左右四个方向是否碰触到边缘，对坐标进行归位，具体实现代码请看 contain 方法。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/contain.jpg" alt="四种碰边缘情况"></p><h2 id="生成子弹" class="post-heading"><a href="#生成子弹" class="headerlink" title="生成子弹"></a>生成子弹<a class="post-anchor" href="#生成子弹" aria-hidden="true"></a></h2><p>在游戏中，我们需要不断的发射子弹，这就存在一个问题，如何管理子弹？</p><p>因为子弹越多会越占用我们的内存，游戏会发现越来越卡，我们使用对象池的方式生成子弹，并且在子弹击中蜜蜂或者超出屏幕时进行销毁。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/createBullet.jpg" alt="创建子弹示意图"></p><p>对象池的本质是复用，通过 Group 和 getFirstExists 来实现。在优化前，我们每次创建子弹都会 new Sprite，使用一次后就丢掉，优化后是创建子弹后会放入对象池中，每次使用从对象池中取，如果对象池中有则使用对象池中的子弹。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.bullets = game.add.group() <span class="comment">// 创建对象池</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bullet = <span class="keyword">this</span>.bullets.getFirstExists(<span class="literal">false</span>) <span class="comment">// 从对象池中取非存活状态的子弹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bullet) &#123; <span class="comment">// 对象池中存在则复用</span></span><br><span class="line">  	bullet.reset(<span class="keyword">this</span>.airplane.x + <span class="number">16</span>, <span class="keyword">this</span>.airplane.y - <span class="number">20</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 对象池中不存在则创建一个放入对象池中</span></span><br><span class="line">  	bullet = game.add.sprite(<span class="keyword">this</span>.airplane.x + <span class="number">27</span>, <span class="keyword">this</span>.airplane.y - <span class="number">15</span>, <span class="string">'bullet'</span>)</span><br><span class="line">  	<span class="keyword">this</span>.bullets.addChild(bullet)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建一群蜜蜂" class="post-heading"><a href="#创建一群蜜蜂" class="headerlink" title="创建一群蜜蜂"></a>创建一群蜜蜂<a class="post-anchor" href="#创建一群蜜蜂" aria-hidden="true"></a></h2><h4 id="整体移动" class="post-heading"><a href="#整体移动" class="headerlink" title="整体移动"></a>整体移动<a class="post-anchor" href="#整体移动" aria-hidden="true"></a></h4><p>创建 5 x 5 小蜜蜂是采用 Group 将所有的小蜜蜂对象放入其中，持续移动 Group，检测 Group 左右是否碰壁，进行反方向移动，但你会发现小蜜蜂的左右的某一列被歼灭后，Group 的宽度会随着小蜜蜂列数的变化而变化，而 Group 的 X 轴坐标还是以原来的宽度输出 X 坐标，这就导致我们在计算碰撞墙壁的时候出现问题。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/galaxingContainer.jpg" alt="整体移动示意图"></p><p>因此我们改为通过 Group 来控制整体移动，小蜜蜂负责碰撞检测，当检测到小蜜蜂碰撞后，进行反方向移动，并跳出循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; galaxians.length; i++) &#123;</span><br><span class="line"> 	<span class="keyword">var</span> cur = galaxians[i]</span><br><span class="line">	<span class="keyword">if</span> (cur.x + cur.parent.x &lt; <span class="number">0</span> || cur.x + cur.parent.x + cur.width &gt; game.world.width) &#123;</span><br><span class="line">   		<span class="comment">// 反向移动</span></span><br><span class="line">    	<span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="随机自杀式袭击" class="post-heading"><a href="#随机自杀式袭击" class="headerlink" title="随机自杀式袭击"></a>随机自杀式袭击<a class="post-anchor" href="#随机自杀式袭击" aria-hidden="true"></a></h4><p>在间隔一段时间后随机小蜜蜂发起攻击，间隔不采用 setInterval 的方式，因为 setInterval 即使在页面最小化或非激活状态依然执行，我们采用 Phaser 提供的 Time 进行间隔触发避免此问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">game.time.events.loop(Phaser.Timer.SECOND * <span class="number">1.5</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="comment">// 每两秒随机一只小蜜蜂</span></span><br><span class="line">  	<span class="keyword">var</span> now = galaxians[(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * galaxians.length)]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如何计算小蜜蜂向飞机发起攻击的运动轨迹，这里要借助三角函数的力量来解决，通过飞机位置和蜜蜂位置，获得对边（a）和邻边（b）的长度，根据勾股定理求出斜边（c）长度，知道各边长度后就能得到三角比。另外有一点，Group 的 X 轴在持续的移动，小蜜蜂会受 Group 影响，所以在移动小蜜蜂时要注意。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/trigonometric_ratio.jpeg" alt="欧股定理示意图"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = airplane.x + airplane.width / <span class="number">2</span> - now.x + now.width /<span class="number">2</span> <span class="comment">// 获取 a 边长度</span></span><br><span class="line"><span class="keyword">var</span> b = airplane.y + airplane.height / <span class="number">2</span> - now.y + now.height / <span class="number">2</span> <span class="comment">// 获取 b 边长度</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">Math</span>.sqrt(a * a + b * b) <span class="comment">// 求出斜边 c 长度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> speedX = a / c * <span class="number">8</span></span><br><span class="line"><span class="keyword">var</span> speedY = b / c * <span class="number">8</span></span><br><span class="line">now.x += speedX</span><br><span class="line">now.y += speedY</span><br></pre></td></tr></table></figure><h2 id="碰撞检测" class="post-heading"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测<a class="post-anchor" href="#碰撞检测" aria-hidden="true"></a></h2><p>在游戏中，我们需要检测子弹与蜜蜂的碰撞和检测蜜蜂与飞机的碰撞，在 2D 游戏中，常用的有轴对齐包围盒（简称 AABB）就是一个每条边都平行于 X 轴或者 Y 轴的矩形。</p><p>AABB 可以用两个点表示：最大点和最小点，在 2D 中，最小点就是左下角的点，而最大点则是右上角的点。</p><p>通过判断 AABB 与 AABB 是否有存在交叉即可得知是否有碰撞。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/AABB.jpeg" alt="AABB示意图"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hitTestRectangle</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> hit = (a.max.x &lt; b.min.x) || (b.max.x &lt; a.min.x) || (a.max.y &lt; b.min.y) || (b.max.y &lt; a.min.y) &#123;</span><br><span class="line">    	<span class="keyword">return</span> !hit</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是 AABB 与 AABB 碰撞检测的原理，当然，你也可以省事采用 Phaser 提供的物理引擎，在 Phaser 中内置了三种物理引擎，分别是：Arcade Physics、P2 Physics 和 Ninja Physics。</p><p>Arcade Physics：是三个中最为简单、性能最快的物理引擎，因为它的碰撞都是采用 AABB 与 AABB 的碰撞，所有的碰撞都是基于一个矩形边界（hitbox）来计算的，所有如果你想碰撞一个圆形的 Sprite，碰撞的则是它的矩形边界，而不是圆形本身，并且支持摩擦力、重力、弹跳、加速等物理效果，适合应用于精度要求不高，较为简单的游戏中。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/arcade.jpg" alt="Arcade Physics示意图"></p><p>P2 Physics：它是一个更为复杂和逼真的物理引擎，使用 P2 你可以创建弹簧、钟摆、马达等东西，它唯一的缺点在于运算量大，对于性能有较高的要求。</p><p>Ninja Physics：比 Arcade Physics 要复杂一点，最初是为 Flash 游戏而创造的，而现在由 Phaser 的作者 Richard Davey 移植到 JavaScript，它与其他物理引擎最大的区别在于支持斜坡碰撞。</p><p><img src="//misc.aotu.io/ONE-SUNDAY/galaxian/ninjaunner.jpg" alt="Ninja Physics示意图"></p><p>下面简单介绍一下 Arcade Physics 的使用方法，首先要启动物理引擎</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">game.physics.startSystem(Phaser.Physics.ARCADE);</span><br></pre></td></tr></table></figure><p>接着是需要为每个对象开启物理效果，显然一个个创建、添加对象并不高效，我更建议的是通过 Group 的形式添加，这样在 Group 上创建的对象都可以开启物理效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">game.physics.arcade.enable(airplane) <span class="comment">// 单独开启方式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> platforms = game.add.group()</span><br><span class="line">platforms.enableBody = <span class="literal">true</span> <span class="comment">// 组开启方式</span></span><br><span class="line">platforms.create(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'airplane'</span>)</span><br></pre></td></tr></table></figure><p>完成这些以后就可以在 update 阶段使用碰撞检测，overlap 方法可传入两个游戏对象，对象可以是 Sprites、Groups 或者 Emitters，可以执行 Sprite 与 Sprite、Sprite 与 Group、Group 与 Group 的碰撞检测，与 collide 方法不同，该方法的物体不会执行任何的物理效果，它只负责碰撞检测。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> 	game.physics.arcade.overlap(object1, object2, overlapCallback, processCallback, callbackContext)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此碰撞检测介绍就到这，关于物理引擎的更多使用方法可移步至官网查看。</p><h2 id="体验地址" class="post-heading"><a href="#体验地址" class="headerlink" title="体验地址"></a>体验地址<a class="post-anchor" href="#体验地址" aria-hidden="true"></a></h2><p><a href="http://jdc.jd.com/demo/Galaxing/" target="_blank" rel="noopener">【点击这里体验】</a>键盘方向键控制移动，空格发射子弹，暂时只支持 PC 端体验，另外游戏还有很多可增加的功能，比如：关卡设计（蜜蜂血量、速度、分数）、蜜蜂发射子弹、蜜蜂贝塞尔曲线移动、蜜蜂归位、音乐音效、爆炸动画等等。</p><h2 id="尾巴" class="post-heading"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴<a class="post-anchor" href="#尾巴" aria-hidden="true"></a></h2><p>如果你希望入门 H5 游戏开发，不妨拿这个练练手，源码你可以在体验地址中查看到，Phaser 是很适合作为你入门 H5 游戏开发的一款游戏引擎，等你熟练使用也希望你能阅读源码，了解其中的原理，本文较为简单，感谢你的阅读。</p><p>我们会定期更新关于「H5游戏开发」的文章，欢迎关注我们的<a href="https://zhuanlan.zhihu.com/snsgame" target="_blank" rel="noopener">知乎专栏</a>。</p><h2 id="参考资料" class="post-heading"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料<a class="post-anchor" href="#参考资料" aria-hidden="true"></a></h2><p><a href="https://github.com/kittykatattack/learningPixi" target="_blank" rel="noopener">Learning Pixi.js</a><br><a href="https://github.com/photonstorm/phaser" target="_blank" rel="noopener">Phaser</a><br><a href="https://www.joshmorony.com/setting-up-ninja-physics-in-phaser/" target="_blank" rel="noopener">Setting up Ninja Physics in Phaser</a><br><a href="https://item.jd.com/12059086.html" target="_blank" rel="noopener">《游戏编程算法与技巧》</a></p><div class="post-tags" style="display:none"><a href="/tags/H5游戏开发/">H5游戏开发</a> <a href="/tags/Phaser/">Phaser</a></div><div class="post-categories" style="display:none"><a href="/cates/H5游戏开发/">H5游戏开发</a></div><div class="post-announce">感谢您的阅读，本文由 <a href="//aotu.io">凹凸实验室</a> 版权所有。如若转载，请注明出处：凹凸实验室（<a href="https://aotu.io/notes/2018/01/28/galaxian/">https://aotu.io/notes/2018/01/28/galaxian/</a>）</div><div class="post-revision"><i class="fa fa-clock-o"></i> <time class="post-updated" datetime="2021-02-02T07:48:05.246Z">上次更新：2021-02-02 15:48:05</time></div></div><div class="post-nav"><div class="post-nav-next"><a href="/notes/2018/03/06/ae2web/" title="动画：从 AE 到 Web">动画：从 AE 到 Web <i class="fa fa-chevron-right"></i></a></div><div class="post-nav-prev"><a href="/notes/2018/01/17/popstar/" title="H5游戏开发：消灭星星"><i class="fa fa-chevron-left"></i> H5游戏开发：消灭星星</a></div></div><div class="post-comments" id="comments"></div><script>var gitalkOpts={id:"bm90ZXMvMjAxOC8wMS8yOC9nYWxheGlhbi8=",owner:"o2team",repo:"o2team.github.io",title:"H5游戏开发：FC小蜜蜂",body:"https://aotu.io/notes/2018/01/28/galaxian/index.html\n\n使用 Phaser 游戏引擎开发，主要介绍游戏引擎的功能及游戏逻辑",clientID:"3c4d153e6874260f9c7e",clientSecret:"dd44012504c6168bc05b9266e0554bb28c62ce15",admin:["ONE-SUNDAY"]}</script></article></div><aside class="mod-side" id="sidebar"><div class="mod-side-sec aotuwx"><img class="aotuwx-qrcode" src="/img/qrcode.jpg" alt="关注我们"><div class="aotuwx-slogan">每周推送精选技术文章</div></div><div class="mod-side-sec works"><div class="mod-side-sec-hd"><h2>服务/产品</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="//taro.jd.com" target="_blank" title="Taro">Taro</a></li><li><a href="//taro-ui.jd.com" target="_blank" title="Taro-UI">Taro-UI</a></li><li><a href="//taro-ext.jd.com" target="_blank" title="Taro 物料市场">Taro 物料市场</a></li><li><a href="//taro-club.jd.com" target="_blank" title="Taro 官方论坛">Taro 官方论坛</a></li><li><a href="//cases.aotu.io/mobi/maga.html" target="_blank" title="拇指期刊">拇指期刊</a></li><li><a href="//athena.aotu.io/" target="_blank" title="Athena">Athena</a></li><li><a href="//guide.aotu.io/" target="_blank" title="前端代码规范">前端代码规范</a></li><li><a href="//halojs.aotu.io/" target="_blank" title="HaloJS">HaloJS</a></li><li><a href="//sign.aotu.io/" target="_blank" title="邮件签名工具">邮件签名工具</a></li><li><a href="//mac.aotu.io/" target="_blank" title="MAC全栈环境">MAC全栈环境</a></li><li><a href="//xcel.aotu.io" target="_blank" title="Excel Filter">Excel Filter</a></li><li><a href="//aotu.jd.com/share/" target="_blank" title="凹凸公开课">凹凸公开课</a></li><li><a href="//at.aotu.io" target="_blank" title="AT-UI">AT-UI</a></li></ul></div></div><div class="mod-side-sec favlinks"><div class="mod-side-sec-hd"><h2>友情链接</h2></div><div class="mod-side-sec-bd"><ul class="mod-side-list"><li><a href="https://www.cloudbase.net" target="_blank" title="小程序·云开发"><img style="width:22px;vertical-align:middle" src="https://img20.360buyimg.com/ling/jfs/t1/57175/5/15617/50216/5dca6729E00cdff5d/631622525425290e.png">小程序·云开发</a></li><li><a href="https://ling.jd.com" target="_blank" title="京东羚珑智能设计">羚珑智能设计</a></li><li><a href="https://jdrd.jd.com" target="_blank" title="京东零售设计服务平台">京东零售设计服务平台</a></li><li><a href="https://jdc.jd.com" target="_blank" title="京东设计中心">JDC京东设计中心</a></li><li><a href="http://dopro.io/" target="_blank" title="腾讯 Deep Ocean">Deep Ocean</a></li><li><a href="http://fex.baidu.com" target="_blank" title="百度Web前端研发部">百度FEX</a></li><li><a href="http://taobaofed.org" target="_blank" title="淘宝前端团队">淘宝FED</a></li><li><a href="http://tgideas.qq.com" target="_blank" title="腾讯互娱设计中心">TGIdeas</a></li><li><a href="http://isux.tencent.com" target="_blank" title="腾讯SNG设计中心">ISUX</a></li><li><a href="http://cdc.tencent.com" target="_blank" title="腾讯用户研究与体验设计中心">CDC</a></li><li><a href="http://ued.ctrip.com" target="_blank" title="携程设计委员会">携程UED</a></li><li><a href="https://uiiiuiii.com/" target="_blank" title="优优教程网">优优教程网</a></li><li><a href="https://www.designup.cn/" target="_blank" title="Designup">Designup</a></li><li><a href="http://eux.baidu.com/" target="_blank" title="百度EUX">百度EUX</a></li></ul></div></div></aside></div></div><div class="mod-backtop" id="backTop"><i class="fa fa-long-arrow-up"></i></div><footer class="mod-ft" id="footer"><div class="grid"><ul class="mod-ft-links"><li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li><li><a href="https://github.com/o2team/o2team.github.io" target="_blank"><i class="fa fa-github-alt"></i></a></li></ul><div class="mod-ft-sec mod-ft-copyright"><p>Designed by <a href="http://aotu.io" target="_blank">凹凸实验室</a> @<a target="_blank" href="http://jdc.jd.com">京东用户体验设计部</a></p><p>Copyright &copy; 2021. All Rights Reserved.</p><p><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备15077732号-2</a></p></div></div></footer><script src="/js/bundle/core.js"></script><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script><script src="/js/post_wx_share.js"></script><script src="/js/bundle/gitalk.js"></script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?e850b980d029480b092fdd7503c3f8de";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript" src="https://tajs.qq.com/stats?sId=53685723" charset="UTF-8"></script></body></html>